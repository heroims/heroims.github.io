{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.266c1c.css","path":"main.266c1c.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.096dc6.js","path":"slider.096dc6.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.266c1c.js","path":"main.266c1c.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.906508.js","path":"mobile.906508.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.DS_Store","hash":"04329d7b64e78cc4bc2fa051e6b0920641f32e47","modified":1502647759000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1502638260000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1502638260000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1502638260000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1502638260000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1502638260000},{"_id":"themes/yilia/_config.yml","hash":"40e1105f05f69a96606ce8ac123021d93bd56318","modified":1502648288000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1502638260000},{"_id":"themes/yilia/README.md","hash":"86757b00d393bd4956a252d92a469f11f2ae8914","modified":1502638260000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1502638260000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1502638260000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1502647780000},{"_id":"source/_posts/移动端Model层与Server服务层自动化.md","hash":"f42ab274f824e6e292fd4554ac0e038a13378289","modified":1502648048000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1502638260000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1502638260000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1502637246000},{"_id":"themes/yilia/.git/index","hash":"1f1762da518cd3d52055283bc09c9acec480c8b2","modified":1502638260000},{"_id":"themes/yilia/.git/packed-refs","hash":"4dc64835d90ebd62d3df9c760251d3ee4fe50711","modified":1502638260000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1502638260000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1502638260000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1502638260000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1502638260000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1502638260000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1502638260000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1502638260000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1502638260000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1502638260000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1502638260000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1502638260000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502638260000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502638260000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1502638260000},{"_id":"themes/yilia/source/.DS_Store","hash":"027b69422bb9ac46d2fac54136ff2d6abee4eef5","modified":1502647765000},{"_id":"themes/yilia/source/main.266c1c.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1502638260000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1502638260000},{"_id":"themes/yilia/source/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1502638260000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1502638260000},{"_id":"themes/yilia/source/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1502638260000},{"_id":"themes/yilia/source/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1502638260000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1502637246000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1502637246000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1502637246000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"46f9d544dd6d44ceed34fc64b978f54fc801c4ec","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"b75e8fff732292fa26b5a0b47cd253d4281e321a","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"9bfcbd9e71401b6da6b2bbbe61e97625ca247b7a","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1502638260000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1502638260000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1502638260000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1502638260000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1502638260000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502638260000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1502638260000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1502638260000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1502638260000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1502638260000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1502638260000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1502638260000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1502638260000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1502638260000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1502638260000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1502638260000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1502638260000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1502638260000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1502638260000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1502638260000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1502638260000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1502638260000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1502638260000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1502638260000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1502638260000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1502638260000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1502638260000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1502638260000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9bb1a4918c1b1ee62ce0a71381990a1978c51b2a","modified":1502638260000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1502638260000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1502638260000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1502638260000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1502638260000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1502638260000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1502638260000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"171b130d25c36f496e4b43e3808707a8f1897729","modified":1502638260000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4d8071322662d313a09ff7b2e716002870d8c94c","modified":1502638260000},{"_id":"themes/yilia/.git/objects/pack/pack-dc811d52ae05a8bc30b54ff9e20af2bfc9e18786.idx","hash":"a40788362b237a46a2499e7fb50358dd0e34be69","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1502638260000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502638260000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1502638260000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502638260000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"46f9d544dd6d44ceed34fc64b978f54fc801c4ec","modified":1502638260000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1502638260000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"46f9d544dd6d44ceed34fc64b978f54fc801c4ec","modified":1502638260000},{"_id":"themes/yilia/.git/objects/pack/pack-dc811d52ae05a8bc30b54ff9e20af2bfc9e18786.pack","hash":"b50a55f6acbbc2640365c83c28337798d277958c","modified":1502638260000},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1502648252000},{"_id":"source/_posts/IOS组件化与工程管理.md","hash":"b63223a1508162da1a2338e5848215bcbb58a6f8","modified":1502648199000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"移动端Model层与Server服务层自动化","date":"2017-01-31T18:09:05.000Z","_content":"\n# Model层自动化\n### 前言（纯属捎带扯一下，后端大咖勿看）\n谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！\n无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。\n上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了\n### 后端的Model层\n后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql\n### 移动端的Model层\n先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。\n自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。\n### Model自动化实现\n上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考https://github.com/google/protobuf/blob/master/docs/third_party.md ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）\n#### Protobuf Convert转码\n下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）\n这里以Python为例，只是因为安装执行方便所以选它\n转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。\n\n```python\n#头文件引用\nimport os\n\nfrom optparse import OptionParser\n#pb转成方便处理的对象\nfrom protoDef import *\n#读取pb的\nfrom protoReader import ProtoReader as reader\n#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法\n\nENUM_TYPE = 'NSInteger'\n#基础类型映射\ntypeMap = {\n'int64': 'NSNumber',\n'int32': 'NSNumber',\n'string': 'NSString',\n'bool': 'NSNumber',\n'float': 'NSNumber',\n'double': 'NSNumber',\n}\n#默认值映射\ndefaultMap = {\n'int64': '@(%s)',\n'int32': '@(%s)',\n'string': '@\"%s\"',\n'bool': '@(%s)',\n'float': '@(%s)',\n'double': '@(%s)',\n}\n\ndef _convertType(pClz):\nif typeMap.has_key(pClz):\nreturn typeMap[pClz]\nreturn pClz\n\ndef _convertDefault(pClz):\nif defaultMap.has_key(pClz):\nreturn defaultMap[pClz]\nreturn 'nil'\n#写文件方法（就是一点点输出oc的方法）\ndef _writeLine(outf, line = ''):\noutf.write(line + '\\n')\n\nclass IOSWriter:\ndef __init__(self, outDir, proto):\nself.outDir = outDir\nself.proto = proto\n\ndef __writeMsg(self, msg):\nif isDeprecated(msg.comment):\nreturn\n\nself.__writeMsgH(msg)#生成.h\nself.__writeMsgM(msg)#生成.m\n\n#为对应类添加前缀做为命名空间（oc没命名空间。。。）\ndef __makeMsgName(self, msg):\nif msg.protoPkg == '不想加前缀的条件':\nreturn msg.name\nreturn msg.protoPkg.upper() + msg.name\n\ndef __writeMsgH(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % msg.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\nimportSet = set()\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif self.proto.hasMsg(field.clz) and field.clz not in importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\nif self.__atClass(field):\n_writeLine(outf, '@class %s;' % importName)\nelse:\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf)\n# declare\n_writeLine(outf, '@interface %s : NSObject' % msgName)\n# field\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif field.repeated:\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray <%s*>* %s;' % (field.name, fieldType))\nelse\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray * %s;' % field.name)\nelif self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nif fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (fieldType, field.name))\nelif fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, '@property(nonatomic, assign) %s %s;' % (fieldType, field.name))\nelse:\nclz = _convertType(field.clz)\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (clz, field.name))\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\ndef __atClass(self, field):\nreturn '@class' in field.comment\n\ndef __writeMsgM(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % msgName)\nfor field in msg.fields:\nif self.proto.hasMsg(field.clz) and self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf, \"\\n@implementation %s\" % msgName)\n_writeLine(outf)\n# repeated\nkvlist = [] #数组内实体类 数组\ndvlist = [] #默认值 数组\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif typeMap.has_key(field.clz) and field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n#默认值设置\nif len(dvlist) > 0:\n_writeLine(outf, \"- (id)init {\")\n_writeLine(outf, \"   if(self=[super init]){ \")\nfor i, (name, default) in enumerate(dvlist):\nline = '''   _%s=%s''' % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, \"   } \")\n_writeLine(outf, \"   return self;\")\n_writeLine(outf, \"} \")\n\n#用了YYModel转换所以有了这个方法\nif len(kvlist) > 0:\n_writeLine(outf, \"+ (NSDictionary *)modelContainerPropertyGenericClass {\")\n_writeLine(outf, \"  return @{\")\nfor i, (name, clz) in enumerate(kvlist):\nline = '''    @\"%s\" : [%s class]''' % (name, clz)\nif i < len(kvlist) - 1:\nline = line + ','\n_writeLine(outf, line)\n_writeLine(outf, \"  };\")\n_writeLine(outf, \"}\")\n\n\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\n#生成枚举，之所以有.h .m是为了搞枚举string\ndef __writeEnum(self, enum):\nif isDeprecated(enum.comment):\nreturn\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\ndef __writeEnumH(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % enum.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\n_writeLine(outf)\n# declare\n_writeLine(outf, 'typedef enum {')\n# field\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0\nfor field in fields:\ni += 1\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif i == len(fields):\n_writeLine(outf, '  %s = %s' % (field.name, field.number))\nelse:\n_writeLine(outf, '  %s = %s,' % (field.name, field.number))\n_writeLine(outf, '} %s;' % enumName)\n_writeLine(outf)\n_writeLine(outf, '%s %sValueOf(NSString *text);' % (enumName, enumName))\n_writeLine(outf, 'NSString* %sDescription(%s value);' % (enumName, enumName))\n\noutf.close()\n\ndef __writeEnumM(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % enumName)\n_writeLine(outf)\n# valueOf\n_writeLine(outf, '%s %sValueOf(NSString *text) {' % (enumName, enumName))\n_writeLine(outf, '  if (text) {')\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0;\nfor field in fields:\nif i == 0:\n_writeLine(outf, '    if ([text isEqualToString:@\"%s\"])' % field.name)\nelse:\n_writeLine(outf, '    else if ([text isEqualToString:@\"%s\"])' % field.name)\n_writeLine(outf, '      return %s;' % field.name)\ni += 1\n_writeLine(outf, '  }')\n_writeLine(outf, '  return -1;')\n_writeLine(outf, '}\\n')\n# description\n_writeLine(outf, 'NSString* %sDescription(%s value) {' % (enumName, enumName))\n_writeLine(outf, '  switch (value) {')\nfor field in fields:\n_writeLine(outf, '    case %s:' % field.name)\n_writeLine(outf, '      return @\"%s\";' % field.name)\n_writeLine(outf, '  }')\n_writeLine(outf, '  return @\"\";')\n_writeLine(outf, '}')\n\noutf.close()\n\ndef write(self):\nfor msg in self.proto.definedMsgs:\nif msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\nelif msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n#写文件到本地\nif __name__ == '__main__':\nparser = OptionParser()\nparser.add_option(\"-r\", \"--root\", dest=\"protoDir\", help=\"root proto dir\", metavar=\"DIR\")\nparser.add_option(\"-f\", \"--file\", dest=\"protoFile\", help=\"input proto file\", metavar=\"FILE\")\nparser.add_option(\"-o\", \"--out\", dest=\"out\", help=\"output dir\", metavar=\"DIR\")\n\noptions, args = parser.parse_args()\n\nif not options.protoDir:\nparser.print_help()\nparser.error('no proto dir')\nif not options.protoFile:\nparser.print_help()\nparser.error('no proto file')\nif not options.out:\nparser.print_help()\nparser.error('no out dir')\n\nif not os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n\n```      \n上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了\n#### Server服务层自动化\n这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。\n源码地址：https://github.com/heroims/ServerAPI\n这里也只是简单说一下\nServerAPI 定义一个请求的地址，重试次数，返回数据转换模式\nServerAPIManager  根据ServerAPI发起请求\nServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）\nServerResult  返回的通用型实体包含解析的字典，错误信息等\n\n总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass\n\n回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。\n","source":"_posts/移动端Model层与Server服务层自动化.md","raw":"---\ntitle: 移动端Model层与Server服务层自动化\ndate: 2017-02-01 02:09:05\ntags:\n---\n\n# Model层自动化\n### 前言（纯属捎带扯一下，后端大咖勿看）\n谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！\n无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。\n上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了\n### 后端的Model层\n后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql\n### 移动端的Model层\n先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。\n自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。\n### Model自动化实现\n上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考https://github.com/google/protobuf/blob/master/docs/third_party.md ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）\n#### Protobuf Convert转码\n下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）\n这里以Python为例，只是因为安装执行方便所以选它\n转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。\n\n```python\n#头文件引用\nimport os\n\nfrom optparse import OptionParser\n#pb转成方便处理的对象\nfrom protoDef import *\n#读取pb的\nfrom protoReader import ProtoReader as reader\n#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法\n\nENUM_TYPE = 'NSInteger'\n#基础类型映射\ntypeMap = {\n'int64': 'NSNumber',\n'int32': 'NSNumber',\n'string': 'NSString',\n'bool': 'NSNumber',\n'float': 'NSNumber',\n'double': 'NSNumber',\n}\n#默认值映射\ndefaultMap = {\n'int64': '@(%s)',\n'int32': '@(%s)',\n'string': '@\"%s\"',\n'bool': '@(%s)',\n'float': '@(%s)',\n'double': '@(%s)',\n}\n\ndef _convertType(pClz):\nif typeMap.has_key(pClz):\nreturn typeMap[pClz]\nreturn pClz\n\ndef _convertDefault(pClz):\nif defaultMap.has_key(pClz):\nreturn defaultMap[pClz]\nreturn 'nil'\n#写文件方法（就是一点点输出oc的方法）\ndef _writeLine(outf, line = ''):\noutf.write(line + '\\n')\n\nclass IOSWriter:\ndef __init__(self, outDir, proto):\nself.outDir = outDir\nself.proto = proto\n\ndef __writeMsg(self, msg):\nif isDeprecated(msg.comment):\nreturn\n\nself.__writeMsgH(msg)#生成.h\nself.__writeMsgM(msg)#生成.m\n\n#为对应类添加前缀做为命名空间（oc没命名空间。。。）\ndef __makeMsgName(self, msg):\nif msg.protoPkg == '不想加前缀的条件':\nreturn msg.name\nreturn msg.protoPkg.upper() + msg.name\n\ndef __writeMsgH(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % msg.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\nimportSet = set()\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif self.proto.hasMsg(field.clz) and field.clz not in importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\nif self.__atClass(field):\n_writeLine(outf, '@class %s;' % importName)\nelse:\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf)\n# declare\n_writeLine(outf, '@interface %s : NSObject' % msgName)\n# field\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif field.repeated:\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray <%s*>* %s;' % (field.name, fieldType))\nelse\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray * %s;' % field.name)\nelif self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nif fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (fieldType, field.name))\nelif fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, '@property(nonatomic, assign) %s %s;' % (fieldType, field.name))\nelse:\nclz = _convertType(field.clz)\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (clz, field.name))\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\ndef __atClass(self, field):\nreturn '@class' in field.comment\n\ndef __writeMsgM(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % msgName)\nfor field in msg.fields:\nif self.proto.hasMsg(field.clz) and self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf, \"\\n@implementation %s\" % msgName)\n_writeLine(outf)\n# repeated\nkvlist = [] #数组内实体类 数组\ndvlist = [] #默认值 数组\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif typeMap.has_key(field.clz) and field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n#默认值设置\nif len(dvlist) > 0:\n_writeLine(outf, \"- (id)init {\")\n_writeLine(outf, \"   if(self=[super init]){ \")\nfor i, (name, default) in enumerate(dvlist):\nline = '''   _%s=%s''' % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, \"   } \")\n_writeLine(outf, \"   return self;\")\n_writeLine(outf, \"} \")\n\n#用了YYModel转换所以有了这个方法\nif len(kvlist) > 0:\n_writeLine(outf, \"+ (NSDictionary *)modelContainerPropertyGenericClass {\")\n_writeLine(outf, \"  return @{\")\nfor i, (name, clz) in enumerate(kvlist):\nline = '''    @\"%s\" : [%s class]''' % (name, clz)\nif i < len(kvlist) - 1:\nline = line + ','\n_writeLine(outf, line)\n_writeLine(outf, \"  };\")\n_writeLine(outf, \"}\")\n\n\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\n#生成枚举，之所以有.h .m是为了搞枚举string\ndef __writeEnum(self, enum):\nif isDeprecated(enum.comment):\nreturn\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\ndef __writeEnumH(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % enum.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\n_writeLine(outf)\n# declare\n_writeLine(outf, 'typedef enum {')\n# field\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0\nfor field in fields:\ni += 1\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif i == len(fields):\n_writeLine(outf, '  %s = %s' % (field.name, field.number))\nelse:\n_writeLine(outf, '  %s = %s,' % (field.name, field.number))\n_writeLine(outf, '} %s;' % enumName)\n_writeLine(outf)\n_writeLine(outf, '%s %sValueOf(NSString *text);' % (enumName, enumName))\n_writeLine(outf, 'NSString* %sDescription(%s value);' % (enumName, enumName))\n\noutf.close()\n\ndef __writeEnumM(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % enumName)\n_writeLine(outf)\n# valueOf\n_writeLine(outf, '%s %sValueOf(NSString *text) {' % (enumName, enumName))\n_writeLine(outf, '  if (text) {')\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0;\nfor field in fields:\nif i == 0:\n_writeLine(outf, '    if ([text isEqualToString:@\"%s\"])' % field.name)\nelse:\n_writeLine(outf, '    else if ([text isEqualToString:@\"%s\"])' % field.name)\n_writeLine(outf, '      return %s;' % field.name)\ni += 1\n_writeLine(outf, '  }')\n_writeLine(outf, '  return -1;')\n_writeLine(outf, '}\\n')\n# description\n_writeLine(outf, 'NSString* %sDescription(%s value) {' % (enumName, enumName))\n_writeLine(outf, '  switch (value) {')\nfor field in fields:\n_writeLine(outf, '    case %s:' % field.name)\n_writeLine(outf, '      return @\"%s\";' % field.name)\n_writeLine(outf, '  }')\n_writeLine(outf, '  return @\"\";')\n_writeLine(outf, '}')\n\noutf.close()\n\ndef write(self):\nfor msg in self.proto.definedMsgs:\nif msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\nelif msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n#写文件到本地\nif __name__ == '__main__':\nparser = OptionParser()\nparser.add_option(\"-r\", \"--root\", dest=\"protoDir\", help=\"root proto dir\", metavar=\"DIR\")\nparser.add_option(\"-f\", \"--file\", dest=\"protoFile\", help=\"input proto file\", metavar=\"FILE\")\nparser.add_option(\"-o\", \"--out\", dest=\"out\", help=\"output dir\", metavar=\"DIR\")\n\noptions, args = parser.parse_args()\n\nif not options.protoDir:\nparser.print_help()\nparser.error('no proto dir')\nif not options.protoFile:\nparser.print_help()\nparser.error('no proto file')\nif not options.out:\nparser.print_help()\nparser.error('no out dir')\n\nif not os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n\n```      \n上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了\n#### Server服务层自动化\n这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。\n源码地址：https://github.com/heroims/ServerAPI\n这里也只是简单说一下\nServerAPI 定义一个请求的地址，重试次数，返回数据转换模式\nServerAPIManager  根据ServerAPI发起请求\nServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）\nServerResult  返回的通用型实体包含解析的字典，错误信息等\n\n总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass\n\n回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。\n","slug":"移动端Model层与Server服务层自动化","published":1,"updated":"2017-08-13T18:14:08.000Z","_id":"cj6b1qzin0000g16a50p75m03","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Model层自动化\"><a href=\"#Model层自动化\" class=\"headerlink\" title=\"Model层自动化\"></a>Model层自动化</h1><h3 id=\"前言（纯属捎带扯一下，后端大咖勿看）\"><a href=\"#前言（纯属捎带扯一下，后端大咖勿看）\" class=\"headerlink\" title=\"前言（纯属捎带扯一下，后端大咖勿看）\"></a>前言（纯属捎带扯一下，后端大咖勿看）</h3><p>谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！<br>无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。<br>上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了</p>\n<h3 id=\"后端的Model层\"><a href=\"#后端的Model层\" class=\"headerlink\" title=\"后端的Model层\"></a>后端的Model层</h3><p>后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql</p>\n<h3 id=\"移动端的Model层\"><a href=\"#移动端的Model层\" class=\"headerlink\" title=\"移动端的Model层\"></a>移动端的Model层</h3><p>先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。<br>自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。</p>\n<h3 id=\"Model自动化实现\"><a href=\"#Model自动化实现\" class=\"headerlink\" title=\"Model自动化实现\"></a>Model自动化实现</h3><p>上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考<a href=\"https://github.com/google/protobuf/blob/master/docs/third_party.md\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/blob/master/docs/third_party.md</a> ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）</p>\n<h4 id=\"Protobuf-Convert转码\"><a href=\"#Protobuf-Convert转码\" class=\"headerlink\" title=\"Protobuf Convert转码\"></a>Protobuf Convert转码</h4><p>下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）<br>这里以Python为例，只是因为安装执行方便所以选它<br>转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。</p>\n<pre><code class=\"python\"><span class=\"comment\">#头文件引用</span>\n<span class=\"keyword\">import</span> os\n\n<span class=\"keyword\">from</span> optparse <span class=\"keyword\">import</span> OptionParser\n<span class=\"comment\">#pb转成方便处理的对象</span>\n<span class=\"keyword\">from</span> protoDef <span class=\"keyword\">import</span> *\n<span class=\"comment\">#读取pb的</span>\n<span class=\"keyword\">from</span> protoReader <span class=\"keyword\">import</span> ProtoReader <span class=\"keyword\">as</span> reader\n<span class=\"comment\">#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法</span>\n\nENUM_TYPE = <span class=\"string\">'NSInteger'</span>\n<span class=\"comment\">#基础类型映射</span>\ntypeMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'NSString'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'NSNumber'</span>,\n}\n<span class=\"comment\">#默认值映射</span>\ndefaultMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'@\"%s\"'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'@(%s)'</span>,\n}\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertType</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> typeMap.has_key(pClz):\n<span class=\"keyword\">return</span> typeMap[pClz]\n<span class=\"keyword\">return</span> pClz\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertDefault</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> defaultMap.has_key(pClz):\n<span class=\"keyword\">return</span> defaultMap[pClz]\n<span class=\"keyword\">return</span> <span class=\"string\">'nil'</span>\n<span class=\"comment\">#写文件方法（就是一点点输出oc的方法）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_writeLine</span><span class=\"params\">(outf, line = <span class=\"string\">''</span>)</span>:</span>\noutf.write(line + <span class=\"string\">'\\n'</span>)\n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOSWriter</span>:</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, outDir, proto)</span>:</span>\nself.outDir = outDir\nself.proto = proto\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsg</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(msg.comment):\n<span class=\"keyword\">return</span>\n\nself.__writeMsgH(msg)<span class=\"comment\">#生成.h</span>\nself.__writeMsgM(msg)<span class=\"comment\">#生成.m</span>\n\n<span class=\"comment\">#为对应类添加前缀做为命名空间（oc没命名空间。。。）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__makeMsgName</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> msg.protoPkg == <span class=\"string\">'不想加前缀的条件'</span>:\n<span class=\"keyword\">return</span> msg.name\n<span class=\"keyword\">return</span> msg.protoPkg.upper() + msg.name\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgH</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % msg.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\nimportSet = set()\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> field.clz <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n<span class=\"keyword\">if</span> self.__atClass(field):\n_writeLine(outf, <span class=\"string\">'@class %s;'</span> % importName)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'@interface %s : NSObject'</span> % msgName)\n<span class=\"comment\"># field</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> field.repeated:\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray &lt;%s*&gt;* %s;'</span> % (field.name, fieldType))\n<span class=\"keyword\">else</span>\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray * %s;'</span> % field.name)\n<span class=\"keyword\">elif</span> self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n<span class=\"keyword\">if</span> fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">elif</span> fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, assign) %s %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">else</span>:\nclz = _convertType(field.clz)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (clz, field.name))\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__atClass</span><span class=\"params\">(self, field)</span>:</span>\n<span class=\"keyword\">return</span> <span class=\"string\">'@class'</span> <span class=\"keyword\">in</span> field.comment\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgM</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % msgName)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf, <span class=\"string\">\"\\n@implementation %s\"</span> % msgName)\n_writeLine(outf)\n<span class=\"comment\"># repeated</span>\nkvlist = [] <span class=\"comment\">#数组内实体类 数组</span>\ndvlist = [] <span class=\"comment\">#默认值 数组</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> typeMap.has_key(field.clz) <span class=\"keyword\">and</span> field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n<span class=\"comment\">#默认值设置</span>\n<span class=\"keyword\">if</span> len(dvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"- (id)init {\"</span>)\n_writeLine(outf, <span class=\"string\">\"   if(self=[super init]){ \"</span>)\n<span class=\"keyword\">for</span> i, (name, default) <span class=\"keyword\">in</span> enumerate(dvlist):\nline = <span class=\"string\">'''   _%s=%s'''</span> % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"   } \"</span>)\n_writeLine(outf, <span class=\"string\">\"   return self;\"</span>)\n_writeLine(outf, <span class=\"string\">\"} \"</span>)\n\n<span class=\"comment\">#用了YYModel转换所以有了这个方法</span>\n<span class=\"keyword\">if</span> len(kvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"+ (NSDictionary *)modelContainerPropertyGenericClass {\"</span>)\n_writeLine(outf, <span class=\"string\">\"  return @{\"</span>)\n<span class=\"keyword\">for</span> i, (name, clz) <span class=\"keyword\">in</span> enumerate(kvlist):\nline = <span class=\"string\">'''    @\"%s\" : [%s class]'''</span> % (name, clz)\n<span class=\"keyword\">if</span> i &lt; len(kvlist) - <span class=\"number\">1</span>:\nline = line + <span class=\"string\">','</span>\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"  };\"</span>)\n_writeLine(outf, <span class=\"string\">\"}\"</span>)\n\n\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"comment\">#生成枚举，之所以有.h .m是为了搞枚举string</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnum</span><span class=\"params\">(self, enum)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(enum.comment):\n<span class=\"keyword\">return</span>\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumH</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % enum.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'typedef enum {'</span>)\n<span class=\"comment\"># field</span>\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\ni += <span class=\"number\">1</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> i == len(fields):\n_writeLine(outf, <span class=\"string\">'  %s = %s'</span> % (field.name, field.number))\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'  %s = %s,'</span> % (field.name, field.number))\n_writeLine(outf, <span class=\"string\">'} %s;'</span> % enumName)\n_writeLine(outf)\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text);'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value);'</span> % (enumName, enumName))\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumM</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % enumName)\n_writeLine(outf)\n<span class=\"comment\"># valueOf</span>\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  if (text) {'</span>)\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>;\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n<span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">'    if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'    else if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return %s;'</span> % field.name)\ni += <span class=\"number\">1</span>\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return -1;'</span>)\n_writeLine(outf, <span class=\"string\">'}\\n'</span>)\n<span class=\"comment\"># description</span>\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  switch (value) {'</span>)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n_writeLine(outf, <span class=\"string\">'    case %s:'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return @\"%s\";'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return @\"\";'</span>)\n_writeLine(outf, <span class=\"string\">'}'</span>)\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(self)</span>:</span>\n<span class=\"keyword\">for</span> msg <span class=\"keyword\">in</span> self.proto.definedMsgs:\n<span class=\"keyword\">if</span> msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\n<span class=\"keyword\">elif</span> msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n<span class=\"comment\">#写文件到本地</span>\n<span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:\nparser = OptionParser()\nparser.add_option(<span class=\"string\">\"-r\"</span>, <span class=\"string\">\"--root\"</span>, dest=<span class=\"string\">\"protoDir\"</span>, help=<span class=\"string\">\"root proto dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\nparser.add_option(<span class=\"string\">\"-f\"</span>, <span class=\"string\">\"--file\"</span>, dest=<span class=\"string\">\"protoFile\"</span>, help=<span class=\"string\">\"input proto file\"</span>, metavar=<span class=\"string\">\"FILE\"</span>)\nparser.add_option(<span class=\"string\">\"-o\"</span>, <span class=\"string\">\"--out\"</span>, dest=<span class=\"string\">\"out\"</span>, help=<span class=\"string\">\"output dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\n\noptions, args = parser.parse_args()\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoDir:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto dir'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoFile:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto file'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.out:\nparser.print_help()\nparser.error(<span class=\"string\">'no out dir'</span>)\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n</code></pre>\n<p>上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了</p>\n<h4 id=\"Server服务层自动化\"><a href=\"#Server服务层自动化\" class=\"headerlink\" title=\"Server服务层自动化\"></a>Server服务层自动化</h4><p>这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。<br>源码地址：<a href=\"https://github.com/heroims/ServerAPI\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPI</a><br>这里也只是简单说一下<br>ServerAPI 定义一个请求的地址，重试次数，返回数据转换模式<br>ServerAPIManager  根据ServerAPI发起请求<br>ServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）<br>ServerResult  返回的通用型实体包含解析的字典，错误信息等</p>\n<p>总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass</p>\n<p>回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Model层自动化\"><a href=\"#Model层自动化\" class=\"headerlink\" title=\"Model层自动化\"></a>Model层自动化</h1><h3 id=\"前言（纯属捎带扯一下，后端大咖勿看）\"><a href=\"#前言（纯属捎带扯一下，后端大咖勿看）\" class=\"headerlink\" title=\"前言（纯属捎带扯一下，后端大咖勿看）\"></a>前言（纯属捎带扯一下，后端大咖勿看）</h3><p>谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！<br>无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。<br>上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了</p>\n<h3 id=\"后端的Model层\"><a href=\"#后端的Model层\" class=\"headerlink\" title=\"后端的Model层\"></a>后端的Model层</h3><p>后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql</p>\n<h3 id=\"移动端的Model层\"><a href=\"#移动端的Model层\" class=\"headerlink\" title=\"移动端的Model层\"></a>移动端的Model层</h3><p>先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。<br>自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。</p>\n<h3 id=\"Model自动化实现\"><a href=\"#Model自动化实现\" class=\"headerlink\" title=\"Model自动化实现\"></a>Model自动化实现</h3><p>上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考<a href=\"https://github.com/google/protobuf/blob/master/docs/third_party.md\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/blob/master/docs/third_party.md</a> ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）</p>\n<h4 id=\"Protobuf-Convert转码\"><a href=\"#Protobuf-Convert转码\" class=\"headerlink\" title=\"Protobuf Convert转码\"></a>Protobuf Convert转码</h4><p>下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）<br>这里以Python为例，只是因为安装执行方便所以选它<br>转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。</p>\n<pre><code class=\"python\"><span class=\"comment\">#头文件引用</span>\n<span class=\"keyword\">import</span> os\n\n<span class=\"keyword\">from</span> optparse <span class=\"keyword\">import</span> OptionParser\n<span class=\"comment\">#pb转成方便处理的对象</span>\n<span class=\"keyword\">from</span> protoDef <span class=\"keyword\">import</span> *\n<span class=\"comment\">#读取pb的</span>\n<span class=\"keyword\">from</span> protoReader <span class=\"keyword\">import</span> ProtoReader <span class=\"keyword\">as</span> reader\n<span class=\"comment\">#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法</span>\n\nENUM_TYPE = <span class=\"string\">'NSInteger'</span>\n<span class=\"comment\">#基础类型映射</span>\ntypeMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'NSString'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'NSNumber'</span>,\n}\n<span class=\"comment\">#默认值映射</span>\ndefaultMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'@\"%s\"'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'@(%s)'</span>,\n}\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertType</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> typeMap.has_key(pClz):\n<span class=\"keyword\">return</span> typeMap[pClz]\n<span class=\"keyword\">return</span> pClz\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertDefault</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> defaultMap.has_key(pClz):\n<span class=\"keyword\">return</span> defaultMap[pClz]\n<span class=\"keyword\">return</span> <span class=\"string\">'nil'</span>\n<span class=\"comment\">#写文件方法（就是一点点输出oc的方法）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_writeLine</span><span class=\"params\">(outf, line = <span class=\"string\">''</span>)</span>:</span>\noutf.write(line + <span class=\"string\">'\\n'</span>)\n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOSWriter</span>:</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, outDir, proto)</span>:</span>\nself.outDir = outDir\nself.proto = proto\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsg</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(msg.comment):\n<span class=\"keyword\">return</span>\n\nself.__writeMsgH(msg)<span class=\"comment\">#生成.h</span>\nself.__writeMsgM(msg)<span class=\"comment\">#生成.m</span>\n\n<span class=\"comment\">#为对应类添加前缀做为命名空间（oc没命名空间。。。）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__makeMsgName</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> msg.protoPkg == <span class=\"string\">'不想加前缀的条件'</span>:\n<span class=\"keyword\">return</span> msg.name\n<span class=\"keyword\">return</span> msg.protoPkg.upper() + msg.name\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgH</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % msg.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\nimportSet = set()\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> field.clz <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n<span class=\"keyword\">if</span> self.__atClass(field):\n_writeLine(outf, <span class=\"string\">'@class %s;'</span> % importName)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'@interface %s : NSObject'</span> % msgName)\n<span class=\"comment\"># field</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> field.repeated:\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray &lt;%s*&gt;* %s;'</span> % (field.name, fieldType))\n<span class=\"keyword\">else</span>\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray * %s;'</span> % field.name)\n<span class=\"keyword\">elif</span> self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n<span class=\"keyword\">if</span> fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">elif</span> fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, assign) %s %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">else</span>:\nclz = _convertType(field.clz)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (clz, field.name))\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__atClass</span><span class=\"params\">(self, field)</span>:</span>\n<span class=\"keyword\">return</span> <span class=\"string\">'@class'</span> <span class=\"keyword\">in</span> field.comment\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgM</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % msgName)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf, <span class=\"string\">\"\\n@implementation %s\"</span> % msgName)\n_writeLine(outf)\n<span class=\"comment\"># repeated</span>\nkvlist = [] <span class=\"comment\">#数组内实体类 数组</span>\ndvlist = [] <span class=\"comment\">#默认值 数组</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> typeMap.has_key(field.clz) <span class=\"keyword\">and</span> field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n<span class=\"comment\">#默认值设置</span>\n<span class=\"keyword\">if</span> len(dvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"- (id)init {\"</span>)\n_writeLine(outf, <span class=\"string\">\"   if(self=[super init]){ \"</span>)\n<span class=\"keyword\">for</span> i, (name, default) <span class=\"keyword\">in</span> enumerate(dvlist):\nline = <span class=\"string\">'''   _%s=%s'''</span> % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"   } \"</span>)\n_writeLine(outf, <span class=\"string\">\"   return self;\"</span>)\n_writeLine(outf, <span class=\"string\">\"} \"</span>)\n\n<span class=\"comment\">#用了YYModel转换所以有了这个方法</span>\n<span class=\"keyword\">if</span> len(kvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"+ (NSDictionary *)modelContainerPropertyGenericClass {\"</span>)\n_writeLine(outf, <span class=\"string\">\"  return @{\"</span>)\n<span class=\"keyword\">for</span> i, (name, clz) <span class=\"keyword\">in</span> enumerate(kvlist):\nline = <span class=\"string\">'''    @\"%s\" : [%s class]'''</span> % (name, clz)\n<span class=\"keyword\">if</span> i &lt; len(kvlist) - <span class=\"number\">1</span>:\nline = line + <span class=\"string\">','</span>\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"  };\"</span>)\n_writeLine(outf, <span class=\"string\">\"}\"</span>)\n\n\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"comment\">#生成枚举，之所以有.h .m是为了搞枚举string</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnum</span><span class=\"params\">(self, enum)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(enum.comment):\n<span class=\"keyword\">return</span>\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumH</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % enum.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'typedef enum {'</span>)\n<span class=\"comment\"># field</span>\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\ni += <span class=\"number\">1</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> i == len(fields):\n_writeLine(outf, <span class=\"string\">'  %s = %s'</span> % (field.name, field.number))\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'  %s = %s,'</span> % (field.name, field.number))\n_writeLine(outf, <span class=\"string\">'} %s;'</span> % enumName)\n_writeLine(outf)\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text);'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value);'</span> % (enumName, enumName))\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumM</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % enumName)\n_writeLine(outf)\n<span class=\"comment\"># valueOf</span>\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  if (text) {'</span>)\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>;\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n<span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">'    if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'    else if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return %s;'</span> % field.name)\ni += <span class=\"number\">1</span>\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return -1;'</span>)\n_writeLine(outf, <span class=\"string\">'}\\n'</span>)\n<span class=\"comment\"># description</span>\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  switch (value) {'</span>)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n_writeLine(outf, <span class=\"string\">'    case %s:'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return @\"%s\";'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return @\"\";'</span>)\n_writeLine(outf, <span class=\"string\">'}'</span>)\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(self)</span>:</span>\n<span class=\"keyword\">for</span> msg <span class=\"keyword\">in</span> self.proto.definedMsgs:\n<span class=\"keyword\">if</span> msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\n<span class=\"keyword\">elif</span> msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n<span class=\"comment\">#写文件到本地</span>\n<span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:\nparser = OptionParser()\nparser.add_option(<span class=\"string\">\"-r\"</span>, <span class=\"string\">\"--root\"</span>, dest=<span class=\"string\">\"protoDir\"</span>, help=<span class=\"string\">\"root proto dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\nparser.add_option(<span class=\"string\">\"-f\"</span>, <span class=\"string\">\"--file\"</span>, dest=<span class=\"string\">\"protoFile\"</span>, help=<span class=\"string\">\"input proto file\"</span>, metavar=<span class=\"string\">\"FILE\"</span>)\nparser.add_option(<span class=\"string\">\"-o\"</span>, <span class=\"string\">\"--out\"</span>, dest=<span class=\"string\">\"out\"</span>, help=<span class=\"string\">\"output dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\n\noptions, args = parser.parse_args()\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoDir:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto dir'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoFile:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto file'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.out:\nparser.print_help()\nparser.error(<span class=\"string\">'no out dir'</span>)\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n</code></pre>\n<p>上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了</p>\n<h4 id=\"Server服务层自动化\"><a href=\"#Server服务层自动化\" class=\"headerlink\" title=\"Server服务层自动化\"></a>Server服务层自动化</h4><p>这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。<br>源码地址：<a href=\"https://github.com/heroims/ServerAPI\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPI</a><br>这里也只是简单说一下<br>ServerAPI 定义一个请求的地址，重试次数，返回数据转换模式<br>ServerAPIManager  根据ServerAPI发起请求<br>ServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）<br>ServerResult  返回的通用型实体包含解析的字典，错误信息等</p>\n<p>总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass</p>\n<p>回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。</p>\n"},{"title":"IOS组件化与工程管理","date":"2017-02-04T18:09:05.000Z","_content":"\n谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。\n# 工程管理\n组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。\n理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？\n因为submodule本身就是git自带的就是git的一部分，常用命令有\n``` \n# 添加子仓库\ngit submodule add 仓库地址 路径\n#初始化所有子仓库\ngit submodule init\n# 更新子仓库\ngit submodule update\n\n# 也可以初始化更新一起\ngit submodule update --init\n```\n\npod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。\n当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。\n上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。\n\n这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立\n```\nPod::Spec.new do |s|\ns.name                  = 'MainWorkSpaceDemo'\ns.version               = '1.0.0'\ns.summary               = 'A new container controller to slide  '\ns.homepage              = 'github.com'\ns.license               = { :type => 'MIT', :file => 'README.md' }\ns.author                = { 'heroims' => 'heroims@163.com' }\ns.source                = { :git => '', :tag => \"#{s.version}\" }\ns.platform              = :ios, '5.0'\ns.source_files          = 'ZYQRouter/*.{h,m}'\ns.requires_arc          = true\n#公共仓库\ns.subspec 'BaseTool' do |ss|\nss.source_files = 'ZYQRouter/*.{h,m}'\nend\n#模块1\ns.subspec 'Module1' do |sss|\nsss.source_files = 'Module1/Module1Lib/*.{h,m}'\nend\n#模块2\ns.subspec 'Module2' do |ssss|\nssss.source_files = 'Module2/Module2Lib/*.{h,m}'\nend\n\nend\n```\n看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便\n然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽\n```\ntarget 'Module1' do\n# Uncomment the next line if you're using Swift or would like to use dynamic frameworks\n# use_frameworks!\n\n# Pods for Module1\npod 'MainWorkSpaceDemo/BaseTool', :path => '../MainWorkSpaceDemo.podspec'\n\ntarget 'Module1Tests' do\ninherit! :search_paths\n# Pods for testing\nend\n\ntarget 'Module1UITests' do\ninherit! :search_paths\n# Pods for testing\nend\n\nend\n```\n就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了\n下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。\n顺便放一下我的ZYQRouter：https://github.com/heroims/ZYQRouter\n里面的demo虽然没用submodule但基本可以阐述完整这套东西。\n正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。\n这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。\n# 页面路由\n关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候\n则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。\n\n顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。\n而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。\n但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。\n另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式\n\n\n```Objective-C\n/**\n重定向 URLPattern 到对应的 newURLPattern \n@param URLPattern 原scheme\n@param newURLPattern 新scheme\n*/\n+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;\n\n/**\n*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;\n\n/**\n*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*                    自带的 key 为 @\"url\" 和 @\"completion\" (如果有的话)\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;\n\n/**\n*  取消注册某个 URL Pattern\n*\n*  @param URLPattern\n*/\n+ (void)deregisterURLPattern:(NSString *)URLPattern;\n\n/**\n*  打开此 URL\n*  会在已注册的 URL -> Handler 中寻找，如果找到，则执行 Handler\n*\n*  @param URL 带 Scheme，如 applink://beauty/3\n*/\n+ (void)openURL:(NSString *)URL;\n\n/**\n*  打开此 URL，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;\n\n/**\n*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param parameters 附加参数\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*/\n+ (id)objectForURL:(NSString *)URL;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*  @param userInfo\n*/\n+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;\n\n/**\n*  是否可以打开URL\n*\n*  @param URL\n*\n*  @return\n*/\n+ (BOOL)canOpenURL:(NSString *)URL;\n\n/**\n*  调用此方法来拼接 urlpattern 和 parameters\n*\n*  #define ROUTE_BEAUTY @\"beauty/:id\"\n*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];\n*\n*\n*  @param pattern    url pattern 比如 @\"beauty/:id\"\n*  @param parameters 一个数组，数量要跟 pattern 里的变量一致\n*\n*  @return\n*/\n+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;\n```\n\n# 方法路由\n关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。\n```Objective-C\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param objectsArr   参数数组 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;\n\n/**\n*\n*  添加未找到Target 或 Action 逻辑\n*\n*  @param notFoundHandler    未找到方法回调\n*  @param targetName    类名\n*\n*  @return\n*/\n+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;\n\n/**\n*  删除Target缓存\n*\n*  @return\n*/\n+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;\n+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;\n+ (void)removeAllTargetsCache;\n\n/**\n不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）\nid result=(__bridge id)zyq_invokeSelectorObjects(@\"Class\", @\"actionWithObj1:obj2:obj3\",obj1,obj2,obj3,nil);\n\nc类型转换配合__bridge_transfer __bridge\n利用IMP返回值只是指针，不支持C基本类型\n\n@param className 类名\n@param selectorName,... 方法名，不定参数\n@return 返回值\n*/\nvoid * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);\n```\n最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。\n","source":"_posts/IOS组件化与工程管理.md","raw":"---\ntitle: IOS组件化与工程管理\ndate: 2017-02-05 02:09:05\ntags:\n---\n\n谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。\n# 工程管理\n组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。\n理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？\n因为submodule本身就是git自带的就是git的一部分，常用命令有\n``` \n# 添加子仓库\ngit submodule add 仓库地址 路径\n#初始化所有子仓库\ngit submodule init\n# 更新子仓库\ngit submodule update\n\n# 也可以初始化更新一起\ngit submodule update --init\n```\n\npod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。\n当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。\n上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。\n\n这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立\n```\nPod::Spec.new do |s|\ns.name                  = 'MainWorkSpaceDemo'\ns.version               = '1.0.0'\ns.summary               = 'A new container controller to slide  '\ns.homepage              = 'github.com'\ns.license               = { :type => 'MIT', :file => 'README.md' }\ns.author                = { 'heroims' => 'heroims@163.com' }\ns.source                = { :git => '', :tag => \"#{s.version}\" }\ns.platform              = :ios, '5.0'\ns.source_files          = 'ZYQRouter/*.{h,m}'\ns.requires_arc          = true\n#公共仓库\ns.subspec 'BaseTool' do |ss|\nss.source_files = 'ZYQRouter/*.{h,m}'\nend\n#模块1\ns.subspec 'Module1' do |sss|\nsss.source_files = 'Module1/Module1Lib/*.{h,m}'\nend\n#模块2\ns.subspec 'Module2' do |ssss|\nssss.source_files = 'Module2/Module2Lib/*.{h,m}'\nend\n\nend\n```\n看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便\n然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽\n```\ntarget 'Module1' do\n# Uncomment the next line if you're using Swift or would like to use dynamic frameworks\n# use_frameworks!\n\n# Pods for Module1\npod 'MainWorkSpaceDemo/BaseTool', :path => '../MainWorkSpaceDemo.podspec'\n\ntarget 'Module1Tests' do\ninherit! :search_paths\n# Pods for testing\nend\n\ntarget 'Module1UITests' do\ninherit! :search_paths\n# Pods for testing\nend\n\nend\n```\n就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了\n下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。\n顺便放一下我的ZYQRouter：https://github.com/heroims/ZYQRouter\n里面的demo虽然没用submodule但基本可以阐述完整这套东西。\n正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。\n这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。\n# 页面路由\n关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候\n则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。\n\n顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。\n而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。\n但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。\n另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式\n\n\n```Objective-C\n/**\n重定向 URLPattern 到对应的 newURLPattern \n@param URLPattern 原scheme\n@param newURLPattern 新scheme\n*/\n+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;\n\n/**\n*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;\n\n/**\n*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*                    自带的 key 为 @\"url\" 和 @\"completion\" (如果有的话)\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;\n\n/**\n*  取消注册某个 URL Pattern\n*\n*  @param URLPattern\n*/\n+ (void)deregisterURLPattern:(NSString *)URLPattern;\n\n/**\n*  打开此 URL\n*  会在已注册的 URL -> Handler 中寻找，如果找到，则执行 Handler\n*\n*  @param URL 带 Scheme，如 applink://beauty/3\n*/\n+ (void)openURL:(NSString *)URL;\n\n/**\n*  打开此 URL，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;\n\n/**\n*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param parameters 附加参数\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*/\n+ (id)objectForURL:(NSString *)URL;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*  @param userInfo\n*/\n+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;\n\n/**\n*  是否可以打开URL\n*\n*  @param URL\n*\n*  @return\n*/\n+ (BOOL)canOpenURL:(NSString *)URL;\n\n/**\n*  调用此方法来拼接 urlpattern 和 parameters\n*\n*  #define ROUTE_BEAUTY @\"beauty/:id\"\n*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];\n*\n*\n*  @param pattern    url pattern 比如 @\"beauty/:id\"\n*  @param parameters 一个数组，数量要跟 pattern 里的变量一致\n*\n*  @return\n*/\n+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;\n```\n\n# 方法路由\n关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。\n```Objective-C\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param objectsArr   参数数组 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;\n\n/**\n*\n*  添加未找到Target 或 Action 逻辑\n*\n*  @param notFoundHandler    未找到方法回调\n*  @param targetName    类名\n*\n*  @return\n*/\n+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;\n\n/**\n*  删除Target缓存\n*\n*  @return\n*/\n+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;\n+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;\n+ (void)removeAllTargetsCache;\n\n/**\n不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）\nid result=(__bridge id)zyq_invokeSelectorObjects(@\"Class\", @\"actionWithObj1:obj2:obj3\",obj1,obj2,obj3,nil);\n\nc类型转换配合__bridge_transfer __bridge\n利用IMP返回值只是指针，不支持C基本类型\n\n@param className 类名\n@param selectorName,... 方法名，不定参数\n@return 返回值\n*/\nvoid * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);\n```\n最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。\n","slug":"IOS组件化与工程管理","published":1,"updated":"2017-08-13T18:16:39.000Z","_id":"cj6b1y0bb0002g16axwobe2gh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。</p>\n<h1 id=\"工程管理\"><a href=\"#工程管理\" class=\"headerlink\" title=\"工程管理\"></a>工程管理</h1><p>组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。<br>理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？<br>因为submodule本身就是git自带的就是git的一部分，常用命令有<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 添加子仓库</div><div class=\"line\">git submodule add 仓库地址 路径</div><div class=\"line\">#初始化所有子仓库</div><div class=\"line\">git submodule init</div><div class=\"line\"># 更新子仓库</div><div class=\"line\">git submodule update</div><div class=\"line\"></div><div class=\"line\"># 也可以初始化更新一起</div><div class=\"line\">git submodule update --init</div></pre></td></tr></table></figure></p>\n<p>pod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。<br>当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。<br>上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。</p>\n<p>这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\">s.name                  = &apos;MainWorkSpaceDemo&apos;</div><div class=\"line\">s.version               = &apos;1.0.0&apos;</div><div class=\"line\">s.summary               = &apos;A new container controller to slide  &apos;</div><div class=\"line\">s.homepage              = &apos;github.com&apos;</div><div class=\"line\">s.license               = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;README.md&apos; &#125;</div><div class=\"line\">s.author                = &#123; &apos;heroims&apos; =&gt; &apos;heroims@163.com&apos; &#125;</div><div class=\"line\">s.source                = &#123; :git =&gt; &apos;&apos;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class=\"line\">s.platform              = :ios, &apos;5.0&apos;</div><div class=\"line\">s.source_files          = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">s.requires_arc          = true</div><div class=\"line\">#公共仓库</div><div class=\"line\">s.subspec &apos;BaseTool&apos; do |ss|</div><div class=\"line\">ss.source_files = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块1</div><div class=\"line\">s.subspec &apos;Module1&apos; do |sss|</div><div class=\"line\">sss.source_files = &apos;Module1/Module1Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块2</div><div class=\"line\">s.subspec &apos;Module2&apos; do |ssss|</div><div class=\"line\">ssss.source_files = &apos;Module2/Module2Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便<br>然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">target &apos;Module1&apos; do</div><div class=\"line\"># Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</div><div class=\"line\"># use_frameworks!</div><div class=\"line\"></div><div class=\"line\"># Pods for Module1</div><div class=\"line\">pod &apos;MainWorkSpaceDemo/BaseTool&apos;, :path =&gt; &apos;../MainWorkSpaceDemo.podspec&apos;</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1Tests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1UITests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了<br>下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。<br>顺便放一下我的ZYQRouter：<a href=\"https://github.com/heroims/ZYQRouter\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ZYQRouter</a><br>里面的demo虽然没用submodule但基本可以阐述完整这套东西。<br>正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。<br>这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。</p>\n<h1 id=\"页面路由\"><a href=\"#页面路由\" class=\"headerlink\" title=\"页面路由\"></a>页面路由</h1><p>关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候<br>则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。</p>\n<p>顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。<br>而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。<br>但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。<br>另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">重定向 URLPattern 到对应的 newURLPattern </div><div class=\"line\">@param URLPattern 原scheme</div><div class=\"line\">@param newURLPattern 新scheme</div><div class=\"line\">*/</div><div class=\"line\">+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*                    自带的 key 为 @&quot;url&quot; 和 @&quot;completion&quot; (如果有的话)</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  取消注册某个 URL Pattern</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern</div><div class=\"line\">*/</div><div class=\"line\">+ (void)deregisterURLPattern:(NSString *)URLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL</div><div class=\"line\">*  会在已注册的 URL -&gt; Handler 中寻找，如果找到，则执行 Handler</div><div class=\"line\">*</div><div class=\"line\">*  @param URL 带 Scheme，如 applink://beauty/3</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param parameters 附加参数</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*  @param userInfo</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  是否可以打开URL</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (BOOL)canOpenURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  调用此方法来拼接 urlpattern 和 parameters</div><div class=\"line\">*</div><div class=\"line\">*  #define ROUTE_BEAUTY @&quot;beauty/:id&quot;</div><div class=\"line\">*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];</div><div class=\"line\">*</div><div class=\"line\">*</div><div class=\"line\">*  @param pattern    url pattern 比如 @&quot;beauty/:id&quot;</div><div class=\"line\">*  @param parameters 一个数组，数量要跟 pattern 里的变量一致</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;</div></pre></td></tr></table></figure>\n<h1 id=\"方法路由\"><a href=\"#方法路由\" class=\"headerlink\" title=\"方法路由\"></a>方法路由</h1><p>关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param objectsArr   参数数组 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  添加未找到Target 或 Action 逻辑</div><div class=\"line\">*</div><div class=\"line\">*  @param notFoundHandler    未找到方法回调</div><div class=\"line\">*  @param targetName    类名</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  删除Target缓存</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;</div><div class=\"line\">+ (void)removeAllTargetsCache;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）</div><div class=\"line\">id result=(__bridge id)zyq_invokeSelectorObjects(@&quot;Class&quot;, @&quot;actionWithObj1:obj2:obj3&quot;,obj1,obj2,obj3,nil);</div><div class=\"line\"></div><div class=\"line\">c类型转换配合__bridge_transfer __bridge</div><div class=\"line\">利用IMP返回值只是指针，不支持C基本类型</div><div class=\"line\"></div><div class=\"line\">@param className 类名</div><div class=\"line\">@param selectorName,... 方法名，不定参数</div><div class=\"line\">@return 返回值</div><div class=\"line\">*/</div><div class=\"line\">void * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);</div></pre></td></tr></table></figure></p>\n<p>最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。</p>\n<h1 id=\"工程管理\"><a href=\"#工程管理\" class=\"headerlink\" title=\"工程管理\"></a>工程管理</h1><p>组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。<br>理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？<br>因为submodule本身就是git自带的就是git的一部分，常用命令有<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 添加子仓库</div><div class=\"line\">git submodule add 仓库地址 路径</div><div class=\"line\">#初始化所有子仓库</div><div class=\"line\">git submodule init</div><div class=\"line\"># 更新子仓库</div><div class=\"line\">git submodule update</div><div class=\"line\"></div><div class=\"line\"># 也可以初始化更新一起</div><div class=\"line\">git submodule update --init</div></pre></td></tr></table></figure></p>\n<p>pod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。<br>当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。<br>上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。</p>\n<p>这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\">s.name                  = &apos;MainWorkSpaceDemo&apos;</div><div class=\"line\">s.version               = &apos;1.0.0&apos;</div><div class=\"line\">s.summary               = &apos;A new container controller to slide  &apos;</div><div class=\"line\">s.homepage              = &apos;github.com&apos;</div><div class=\"line\">s.license               = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;README.md&apos; &#125;</div><div class=\"line\">s.author                = &#123; &apos;heroims&apos; =&gt; &apos;heroims@163.com&apos; &#125;</div><div class=\"line\">s.source                = &#123; :git =&gt; &apos;&apos;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class=\"line\">s.platform              = :ios, &apos;5.0&apos;</div><div class=\"line\">s.source_files          = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">s.requires_arc          = true</div><div class=\"line\">#公共仓库</div><div class=\"line\">s.subspec &apos;BaseTool&apos; do |ss|</div><div class=\"line\">ss.source_files = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块1</div><div class=\"line\">s.subspec &apos;Module1&apos; do |sss|</div><div class=\"line\">sss.source_files = &apos;Module1/Module1Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块2</div><div class=\"line\">s.subspec &apos;Module2&apos; do |ssss|</div><div class=\"line\">ssss.source_files = &apos;Module2/Module2Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便<br>然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">target &apos;Module1&apos; do</div><div class=\"line\"># Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</div><div class=\"line\"># use_frameworks!</div><div class=\"line\"></div><div class=\"line\"># Pods for Module1</div><div class=\"line\">pod &apos;MainWorkSpaceDemo/BaseTool&apos;, :path =&gt; &apos;../MainWorkSpaceDemo.podspec&apos;</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1Tests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1UITests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了<br>下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。<br>顺便放一下我的ZYQRouter：<a href=\"https://github.com/heroims/ZYQRouter\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ZYQRouter</a><br>里面的demo虽然没用submodule但基本可以阐述完整这套东西。<br>正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。<br>这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。</p>\n<h1 id=\"页面路由\"><a href=\"#页面路由\" class=\"headerlink\" title=\"页面路由\"></a>页面路由</h1><p>关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候<br>则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。</p>\n<p>顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。<br>而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。<br>但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。<br>另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">重定向 URLPattern 到对应的 newURLPattern </div><div class=\"line\">@param URLPattern 原scheme</div><div class=\"line\">@param newURLPattern 新scheme</div><div class=\"line\">*/</div><div class=\"line\">+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*                    自带的 key 为 @&quot;url&quot; 和 @&quot;completion&quot; (如果有的话)</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  取消注册某个 URL Pattern</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern</div><div class=\"line\">*/</div><div class=\"line\">+ (void)deregisterURLPattern:(NSString *)URLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL</div><div class=\"line\">*  会在已注册的 URL -&gt; Handler 中寻找，如果找到，则执行 Handler</div><div class=\"line\">*</div><div class=\"line\">*  @param URL 带 Scheme，如 applink://beauty/3</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param parameters 附加参数</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*  @param userInfo</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  是否可以打开URL</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (BOOL)canOpenURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  调用此方法来拼接 urlpattern 和 parameters</div><div class=\"line\">*</div><div class=\"line\">*  #define ROUTE_BEAUTY @&quot;beauty/:id&quot;</div><div class=\"line\">*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];</div><div class=\"line\">*</div><div class=\"line\">*</div><div class=\"line\">*  @param pattern    url pattern 比如 @&quot;beauty/:id&quot;</div><div class=\"line\">*  @param parameters 一个数组，数量要跟 pattern 里的变量一致</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;</div></pre></td></tr></table></figure>\n<h1 id=\"方法路由\"><a href=\"#方法路由\" class=\"headerlink\" title=\"方法路由\"></a>方法路由</h1><p>关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param objectsArr   参数数组 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  添加未找到Target 或 Action 逻辑</div><div class=\"line\">*</div><div class=\"line\">*  @param notFoundHandler    未找到方法回调</div><div class=\"line\">*  @param targetName    类名</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  删除Target缓存</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;</div><div class=\"line\">+ (void)removeAllTargetsCache;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）</div><div class=\"line\">id result=(__bridge id)zyq_invokeSelectorObjects(@&quot;Class&quot;, @&quot;actionWithObj1:obj2:obj3&quot;,obj1,obj2,obj3,nil);</div><div class=\"line\"></div><div class=\"line\">c类型转换配合__bridge_transfer __bridge</div><div class=\"line\">利用IMP返回值只是指针，不支持C基本类型</div><div class=\"line\"></div><div class=\"line\">@param className 类名</div><div class=\"line\">@param selectorName,... 方法名，不定参数</div><div class=\"line\">@return 返回值</div><div class=\"line\">*/</div><div class=\"line\">void * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);</div></pre></td></tr></table></figure></p>\n<p>最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}