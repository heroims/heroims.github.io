{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.266c1c.css","path":"main.266c1c.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.096dc6.js","path":"slider.096dc6.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.266c1c.js","path":"main.266c1c.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.906508.js","path":"mobile.906508.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1502648252000},{"_id":"themes/yilia/.DS_Store","hash":"bdeb05b1c83f40a11454f050a4ddf545bfbe7046","modified":1502648817000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1502638260000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1502638260000},{"_id":"themes/yilia/_config.yml","hash":"2f62dd5c5b1c1126a6a3e66644011c872d24a1fe","modified":1502656357000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1502638260000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1502638260000},{"_id":"themes/yilia/README.md","hash":"86757b00d393bd4956a252d92a469f11f2ae8914","modified":1502638260000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1502638260000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1502638260000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1502647780000},{"_id":"source/_posts/IOS 切面统计事件解耦.md","hash":"7a07be324ec4e37fe9d2ece2f226a9f024cff435","modified":1502656168000},{"_id":"source/_posts/IOS 百行代码切面日志.md","hash":"c68614acca87573feedf22236ad83166682759ec","modified":1502656131000},{"_id":"source/_posts/IOS 网络服务层自动化详解.md","hash":"0ea48679ff0d0b7e042b89dab5fbe67fef852a3f","modified":1502656195000},{"_id":"source/_posts/IOS本地化:国际化项目配置.md","hash":"2ebff83b3c83a8aac23ca0af6d0bfcb23f492793","modified":1502656254000},{"_id":"source/_posts/IOS组件化与工程管理.md","hash":"4a94b2c96d47a72fe6286d6924c301694a113ebc","modified":1502656271000},{"_id":"source/_posts/移动端Model层与Server服务层自动化.md","hash":"d955bc4cf731a7680b6b6cb02ba7524755dead77","modified":1502656086000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1502638260000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1502638260000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1502638260000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1502638260000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1502638260000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1502638260000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1502638260000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1502638260000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1502638260000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1502638260000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1502638260000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502638260000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502638260000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1502638260000},{"_id":"themes/yilia/source/.DS_Store","hash":"027b69422bb9ac46d2fac54136ff2d6abee4eef5","modified":1502647765000},{"_id":"themes/yilia/source/main.266c1c.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1502638260000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1502638260000},{"_id":"themes/yilia/source/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1502638260000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1502638260000},{"_id":"themes/yilia/source/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1502638260000},{"_id":"themes/yilia/source/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"b75e8fff732292fa26b5a0b47cd253d4281e321a","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"9bfcbd9e71401b6da6b2bbbe61e97625ca247b7a","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1502638260000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1502638260000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1502638260000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502638260000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1502638260000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1502638260000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502638260000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1502638260000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1502638260000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1502638260000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1502638260000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1502638260000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1502638260000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1502638260000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1502638260000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1502638260000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1502638260000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1502638260000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1502638260000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1502638260000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1502638260000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1502638260000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1502638260000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1502638260000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1502638260000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1502638260000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1502638260000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1502638260000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1502638260000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1502638260000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1502638260000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9bb1a4918c1b1ee62ce0a71381990a1978c51b2a","modified":1502638260000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1502638260000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1502638260000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1502638260000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1502638260000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1502638260000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1502638260000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"171b130d25c36f496e4b43e3808707a8f1897729","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1502638260000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1502638260000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1502638260000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1502638260000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1502638260000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502638260000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502638260000},{"_id":"public/content.json","hash":"6c4694dcc2225dedcc93ea85a7d1189f40ff1371","modified":1502656367549},{"_id":"public/2017/08/02/IOS 切面统计事件解耦/index.html","hash":"ac93444910e596f33f1648f9901c71e4a5688908","modified":1502656367719},{"_id":"public/2017/03/22/IOS 百行代码切面日志/index.html","hash":"2bba6284f5f92fd597f49b4bcc360591e9e5879b","modified":1502656367719},{"_id":"public/2017/03/02/IOS 网络服务层自动化详解/index.html","hash":"656f0841c0af96eea329ce5c054add83e8cad55f","modified":1502656367719},{"_id":"public/2017/02/15/IOS本地化:国际化项目配置/index.html","hash":"a8d128a40238982f77872be117532ccd6eba55f2","modified":1502656367719},{"_id":"public/2017/02/05/IOS组件化与工程管理/index.html","hash":"c5f7993d252bbdf7abfb3f0835ae8aa9eb520dfc","modified":1502656367720},{"_id":"public/2017/02/01/移动端Model层与Server服务层自动化/index.html","hash":"6251bf0471933cccf895a6cb1e2bb0df0635b83e","modified":1502656367720},{"_id":"public/index.html","hash":"a9e312f662551c0b9632cba724acd3beb82eff10","modified":1502656367720},{"_id":"public/archives/index.html","hash":"833e86ea32b994ce559b90c183e098e10628df88","modified":1502656367720},{"_id":"public/archives/2017/index.html","hash":"33e7184d8543c76187d122eed823fda12f627196","modified":1502656367720},{"_id":"public/archives/2017/02/index.html","hash":"89187df5ebb8997e5cc21a088ad1c9cceb25e118","modified":1502656367721},{"_id":"public/archives/2017/03/index.html","hash":"d08b13f90acc5d7c7e8cfb5ffdb8a0d580135026","modified":1502656367721},{"_id":"public/archives/2017/08/index.html","hash":"c2c6e9973723a77509e05e4ae7bf014a020aedd7","modified":1502656367721}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"IOS 切面统计事件解耦","date":"2017-08-01T18:09:05.000Z","_content":"\n统计这个事情可以说是个巨无语的系统，当然不把他独立出来也就不是什么问题了，只是一堆牛皮癣似得代码穿插在项目各个地方，毕竟真正应用到一个app里的统计都跟业务有着很强的绑定关系，脱离业务的统计数据基本没什么大用，先吐槽一波再开始正文。。。。\n![DingTalk20170802140347.png](http://upload-images.jianshu.io/upload_images/3994053-18807a49c709e49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 基础封装\n先从用第三方的来说，基本上就只是需要包个壳就ok了，建个manager，初始化sdk一封装，加几个常用统计方法基本ok。常见的方法就是传个event名再加个properties传扩展字典，用户登录状态绑定注销，通用字段增删改，基本上这就满足了大部分需求。。。\n\n如果是纯自己手写，上面说的壳放着，剩下的仿照sdk来，基本功能要实现异步队列记录往本地写数据，定期上传，处理好读写关系是关键，这里不多说不是这篇重点。\n\nps:有个壳才敢放开手折腾优化\n\n#### 切面封装\n切面统计其实可以看我之前的[IOS 百行代码切面日志](http://www.jianshu.com/p/a9219e618ca2)，整个完成的就是切面的封装，看过的基本应该了解这套逻辑切面的时候不关心切面方法的参数的话会非常好用。\n如果业务关联强的情况，虽然也能处理但要针对那些业务作出对应的逻辑，导致切面封装里夹杂很多特殊逻辑,下面的方法内部要对originAOP拆分取所有参，甚至要复制部分业务层逻辑过来最后完成一个统计。\n```\n-(void)al_logger:(id)log originAOP:(id)originAOP\n```\n所以我个人建议这里就封装些简单的少参甚至无参的统计，然后基本上简单的通用统计和业务统计建个类或者plist，列一下要切面的类和方法就完成了。\n\n凡事都有特例，如果本身方法内多个参数完成一次统计就不多，那我之前的百行系列就已经足够你解耦了。\n\nps:郑重声明AOP 至少我现在还没发现IOS里怎么实现切面静态方法（类方法）\n# 通用统计\n通用统计就是可以脱离业务完全抽离的部分，这部分其实可以设计部分业务承接，比如通用点击事件可以把点击的UI对象扩展出一个字典的属性值，如此对于通用统计来说只是看看有没有某个属性有的话就扔到统计里，和业务层没有关联，但后面带来的好处很大！这个最后说。\n#### App生命周期统计\n应用生命周期的统计随便建个类，监听下面的通知就ok了，当然这个类就不能销毁了，比较懒得做法直接AOPLogger 类扩展一下init里监听，因为我本身的类里连init方法都没重写。\n<!-- more -->\nUIApplicationDidFinishLaunchingNotification （通知名称） --->   application:didFinishLaunchingWithOptions:(委托方法）：在应用程序启动后直接进行应用程序级编码的主要方式。\n\nUIApplicationWillResignActiveNotification(通知名称）--->applicationWillResignActive:（委托方法）：用户按下主屏幕按钮调用 ，不要在此方法中假设将进入后台状态，只是一种临时变化，最终将恢复到活动状态\n\nUIApplicationDidBecomActiveNotification（通知名称） ---->applicationDidBecomeActive:(委托方法）：应用程序按下主屏幕按钮后想要将应用程序切换到前台时调用，应用程序启动时也会调用，可以在其中添加一些应用程序初始化代码\n\nUIApplicationDidEnterBackgroundNotification(通知名称）----->applicationDidEnterBackground:（委托方法）：应用程序在此方法中释放所有可在以后重新创建的资源，保存所有用户数据，关闭网络连接等。如果需要，也可以在这里请求在后台运行更长时间。如果在这里花费了太长时间（超过5秒），系统将断定应用程序的行为异常并终止他。\n\nUIApplicationWillEnterForegroundNotification(通知名称） ---->applicationWillEnterForeground:(委托方法):当应用程序在applicationDidEnterBackground:花费了太长时间，终止后，应该实现此方法来重新创建在applicationDidEnterBackground中销毁的内容，比如重新加载用户数据、重新建立网络连接等。\n\nUIApplicationWllTerminateNotification（通知名称） ----> applicationWillTerminate:(委托方法):现在很少使用，只有在应用程序已进入后台，并且系统出于某种原因决定跳过暂停状态并终止应用程序时，才会真正调用它。\n\n#### 点击事件（不包括手势）\n这里点击事件切面分为3类\n1.UIControl的addTarget触发，UIButton都会走UIApplication里的这方法，但需要忽略一部分，不然会和第二个部分重叠，而且手势addTarget不走，不过手势不走正好可以区分手势\n```\n-(void)sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;\n```\n2.设置delegate委托式系统点击触发，这里直接切了UICollectionView，UITableView，UITabBarController，UITabBar，UIAlertView，UIActionSheet这几个setDelegate方法，然后加标识判断切委托方法，用Aspects库的方法swizzing因为他不允许重复swizzing算双保险。\n\n3.UIAlertAction切block属性的set方法，每次setBlock的时候替换成我自己的block，在我的block内执行设置的block。\n\n下面就是协议，用pod的话AOPLogger/AOPClick就有了，用的时候类扩展一下AOPLogger遵守协议实现对应方法\n```\n@protocol AOPLoggerClickProtocol <NSObject>\n\n@optional\n- (void)alcp_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;\n- (void)alcp_customIgnore_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;\n- (void)alcp_collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;\n- (void)alcp_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;\n- (void)alcp_tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController from:(id)sender;\n- (void)alcp_tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item from:(id)sender;\n- (void)alcp_alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;\n- (void)alcp_actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;\n- (void)alcp_alertControllerAction:(UIAlertAction *)action from:(id)sender;\n\n@end\n```\nps:覆盖可能不全，漏了什么欢迎git提pull request\n\n#### 手势统计\n这个是切了UIView的addGestureRecognizer方法，每次添加手势的时候我多加个自己AOPLogger的taget-action到gestureRecognizer对象上，这样手势统计就搞定了。\n如果要用这个统计点击和长按，判断一下状态是结束的时候统计gestureRecognizer类型是UITapGestureRecognizer,UILongPressGestureRecognizer就行，其实手势的统计或许都在结束的时候统计区分下类型就够了吧！\n```\n@protocol AOPLoggerGestureRecognizerProtocol <NSObject>\n\n@optional\n-(void)algrp_handleGesture:(UIGestureRecognizer*)gestureRecognizer;\n\n@end\n```\n#### 页面统计\n这个太寻常了，感觉没什么好说，使用方法如上，之所以还提供个pod的AOPLogger/AOPPageView,主要是如果要统计浏览时长逻辑，自己方便实现（如显示的时候runtime随便塞个date进去，消失的时候算一下上报），还有我默认预先忽略了部分页面,省了自己写。\n```\n@protocol AOPLoggerPageViewProtocol <NSObject>\n\n@optional\n-(BOOL)alpvp_viewIgnore:(id)sender;\n-(void)alpvp_viewDidAppear:(BOOL)animated sender:(id)sender;\n-(void)alpvp_viewDidDisappear:(BOOL)animated sender:(id)sender;\n\n@end\n```\n# 业务统计\n业务统计首先放的位置要保证在对应业务线的目录里，毕竟跟业务关联密切，大的业务逻辑调整的时候看一下放业务统计目录下对应的地方需不需要修改。\n#### 无参数方法统计\n这一类就是需要写在业务层里但统计的时候只记录一个Event名，比如有个方法-(void)abc:(id)a b:(id)b c:(id)c;我只是记录他被调用，这种直接AOPLogger调用下[AOPLogger AOPLoggerWithClassString:classString methodString:@\"abc:b:c\" log:@\"abc\"]或扔plist里默认直接解决。\n#### 方法内逻辑处理统计\n这个就有点厉害了，比如下订单的时候我买了一堆东西里面带着各种商品属性，要你把某种属性的商品做统计，只是举例...这时候直接写这个类的类扩展load方法里切面然后写逻辑处理统计，这里不建议用Aspects库，底层保证切一个类的一个方法一次是好用的，可业务层各种奇葩逻辑都会有，想解耦经常用奇招所以最好允许多次切面，dispatch_once保证自己的逻辑需要的切一次就可以了，可以用我简单封装的方法。\n```\n@interface NSObject (AOPLogger)\n\n+(void)al_hookOrAddWithOriginSeletor:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector error:(NSError**)error;\n\n@end\n```\n#### 前后逻辑关联统计\n这个可以结合点击来讲，比上面还要让人头疼，类似统计我查看一个东西，要记录我在哪点击的查看以及当前页面的数据属性，还有从哪来到当前页面的，要查看东西的id。这个时候就需要结合通用统计来搞了，我们在最底层可以做的是把本身点击的UI对象的默认字典属性和最上层页面的默认字典属性以及点击对象target上层UI对象的默认字典属性做统计，最上层的激活页面这个是可以在任何地方搞出来的，回头我可以把类扩展放上来，在任何页面都可以拿到当前页面，前一个页面以及页面属于第几层。底层在响应默认点击事件之前处理我们的统计逻辑，接下来就是怎么把属性赋值，这个时候就需要我们去切面当前页面里做model赋值的方法然后同时把想要统计的属性赋值到当前页面的默认字典属性里，如果这是cell上的button那么赋值cell的时候就可以切面。\n\n总的来说就是寻找UI对象赋值点，然后切面为UI对象添加统计属性，我们runtime加到所有UI对象上隐藏的默认字典属性字段专门承接关联信息，底层只做读取整合，业务层切面赋值。\n\n这个时候就会发现数据对象与UI对象绑定协议的制定会直接决定实现的复杂度。\n#### 后序\n业务层的统计我个人认为原则上尽量后端做这个事，毕竟要保证统计数据的正确性，其实减少前端统计很重要，毕竟现在web（pc网页），wap（手机网页），小程序，安卓，ios一牵扯业务逻辑统计非常需要统一校准，不然数据绝对超乎你的想象。\n# 归纳统计解耦思路\n统计放到其他端其实解耦思路也是大致相同。。。下面总结：\n1.找底层触发的事件点\n2.业务层找赋值点\n3.使用AOP的思路对上面的地方进行插入我们的统计逻辑\n","source":"_posts/IOS 切面统计事件解耦.md","raw":"---\ntitle: IOS 切面统计事件解耦\ndate: 2017-08-02 02:09:05\ntags:\n---\n\n统计这个事情可以说是个巨无语的系统，当然不把他独立出来也就不是什么问题了，只是一堆牛皮癣似得代码穿插在项目各个地方，毕竟真正应用到一个app里的统计都跟业务有着很强的绑定关系，脱离业务的统计数据基本没什么大用，先吐槽一波再开始正文。。。。\n![DingTalk20170802140347.png](http://upload-images.jianshu.io/upload_images/3994053-18807a49c709e49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 基础封装\n先从用第三方的来说，基本上就只是需要包个壳就ok了，建个manager，初始化sdk一封装，加几个常用统计方法基本ok。常见的方法就是传个event名再加个properties传扩展字典，用户登录状态绑定注销，通用字段增删改，基本上这就满足了大部分需求。。。\n\n如果是纯自己手写，上面说的壳放着，剩下的仿照sdk来，基本功能要实现异步队列记录往本地写数据，定期上传，处理好读写关系是关键，这里不多说不是这篇重点。\n\nps:有个壳才敢放开手折腾优化\n\n#### 切面封装\n切面统计其实可以看我之前的[IOS 百行代码切面日志](http://www.jianshu.com/p/a9219e618ca2)，整个完成的就是切面的封装，看过的基本应该了解这套逻辑切面的时候不关心切面方法的参数的话会非常好用。\n如果业务关联强的情况，虽然也能处理但要针对那些业务作出对应的逻辑，导致切面封装里夹杂很多特殊逻辑,下面的方法内部要对originAOP拆分取所有参，甚至要复制部分业务层逻辑过来最后完成一个统计。\n```\n-(void)al_logger:(id)log originAOP:(id)originAOP\n```\n所以我个人建议这里就封装些简单的少参甚至无参的统计，然后基本上简单的通用统计和业务统计建个类或者plist，列一下要切面的类和方法就完成了。\n\n凡事都有特例，如果本身方法内多个参数完成一次统计就不多，那我之前的百行系列就已经足够你解耦了。\n\nps:郑重声明AOP 至少我现在还没发现IOS里怎么实现切面静态方法（类方法）\n# 通用统计\n通用统计就是可以脱离业务完全抽离的部分，这部分其实可以设计部分业务承接，比如通用点击事件可以把点击的UI对象扩展出一个字典的属性值，如此对于通用统计来说只是看看有没有某个属性有的话就扔到统计里，和业务层没有关联，但后面带来的好处很大！这个最后说。\n#### App生命周期统计\n应用生命周期的统计随便建个类，监听下面的通知就ok了，当然这个类就不能销毁了，比较懒得做法直接AOPLogger 类扩展一下init里监听，因为我本身的类里连init方法都没重写。\n<!-- more -->\nUIApplicationDidFinishLaunchingNotification （通知名称） --->   application:didFinishLaunchingWithOptions:(委托方法）：在应用程序启动后直接进行应用程序级编码的主要方式。\n\nUIApplicationWillResignActiveNotification(通知名称）--->applicationWillResignActive:（委托方法）：用户按下主屏幕按钮调用 ，不要在此方法中假设将进入后台状态，只是一种临时变化，最终将恢复到活动状态\n\nUIApplicationDidBecomActiveNotification（通知名称） ---->applicationDidBecomeActive:(委托方法）：应用程序按下主屏幕按钮后想要将应用程序切换到前台时调用，应用程序启动时也会调用，可以在其中添加一些应用程序初始化代码\n\nUIApplicationDidEnterBackgroundNotification(通知名称）----->applicationDidEnterBackground:（委托方法）：应用程序在此方法中释放所有可在以后重新创建的资源，保存所有用户数据，关闭网络连接等。如果需要，也可以在这里请求在后台运行更长时间。如果在这里花费了太长时间（超过5秒），系统将断定应用程序的行为异常并终止他。\n\nUIApplicationWillEnterForegroundNotification(通知名称） ---->applicationWillEnterForeground:(委托方法):当应用程序在applicationDidEnterBackground:花费了太长时间，终止后，应该实现此方法来重新创建在applicationDidEnterBackground中销毁的内容，比如重新加载用户数据、重新建立网络连接等。\n\nUIApplicationWllTerminateNotification（通知名称） ----> applicationWillTerminate:(委托方法):现在很少使用，只有在应用程序已进入后台，并且系统出于某种原因决定跳过暂停状态并终止应用程序时，才会真正调用它。\n\n#### 点击事件（不包括手势）\n这里点击事件切面分为3类\n1.UIControl的addTarget触发，UIButton都会走UIApplication里的这方法，但需要忽略一部分，不然会和第二个部分重叠，而且手势addTarget不走，不过手势不走正好可以区分手势\n```\n-(void)sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;\n```\n2.设置delegate委托式系统点击触发，这里直接切了UICollectionView，UITableView，UITabBarController，UITabBar，UIAlertView，UIActionSheet这几个setDelegate方法，然后加标识判断切委托方法，用Aspects库的方法swizzing因为他不允许重复swizzing算双保险。\n\n3.UIAlertAction切block属性的set方法，每次setBlock的时候替换成我自己的block，在我的block内执行设置的block。\n\n下面就是协议，用pod的话AOPLogger/AOPClick就有了，用的时候类扩展一下AOPLogger遵守协议实现对应方法\n```\n@protocol AOPLoggerClickProtocol <NSObject>\n\n@optional\n- (void)alcp_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;\n- (void)alcp_customIgnore_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;\n- (void)alcp_collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;\n- (void)alcp_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;\n- (void)alcp_tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController from:(id)sender;\n- (void)alcp_tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item from:(id)sender;\n- (void)alcp_alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;\n- (void)alcp_actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;\n- (void)alcp_alertControllerAction:(UIAlertAction *)action from:(id)sender;\n\n@end\n```\nps:覆盖可能不全，漏了什么欢迎git提pull request\n\n#### 手势统计\n这个是切了UIView的addGestureRecognizer方法，每次添加手势的时候我多加个自己AOPLogger的taget-action到gestureRecognizer对象上，这样手势统计就搞定了。\n如果要用这个统计点击和长按，判断一下状态是结束的时候统计gestureRecognizer类型是UITapGestureRecognizer,UILongPressGestureRecognizer就行，其实手势的统计或许都在结束的时候统计区分下类型就够了吧！\n```\n@protocol AOPLoggerGestureRecognizerProtocol <NSObject>\n\n@optional\n-(void)algrp_handleGesture:(UIGestureRecognizer*)gestureRecognizer;\n\n@end\n```\n#### 页面统计\n这个太寻常了，感觉没什么好说，使用方法如上，之所以还提供个pod的AOPLogger/AOPPageView,主要是如果要统计浏览时长逻辑，自己方便实现（如显示的时候runtime随便塞个date进去，消失的时候算一下上报），还有我默认预先忽略了部分页面,省了自己写。\n```\n@protocol AOPLoggerPageViewProtocol <NSObject>\n\n@optional\n-(BOOL)alpvp_viewIgnore:(id)sender;\n-(void)alpvp_viewDidAppear:(BOOL)animated sender:(id)sender;\n-(void)alpvp_viewDidDisappear:(BOOL)animated sender:(id)sender;\n\n@end\n```\n# 业务统计\n业务统计首先放的位置要保证在对应业务线的目录里，毕竟跟业务关联密切，大的业务逻辑调整的时候看一下放业务统计目录下对应的地方需不需要修改。\n#### 无参数方法统计\n这一类就是需要写在业务层里但统计的时候只记录一个Event名，比如有个方法-(void)abc:(id)a b:(id)b c:(id)c;我只是记录他被调用，这种直接AOPLogger调用下[AOPLogger AOPLoggerWithClassString:classString methodString:@\"abc:b:c\" log:@\"abc\"]或扔plist里默认直接解决。\n#### 方法内逻辑处理统计\n这个就有点厉害了，比如下订单的时候我买了一堆东西里面带着各种商品属性，要你把某种属性的商品做统计，只是举例...这时候直接写这个类的类扩展load方法里切面然后写逻辑处理统计，这里不建议用Aspects库，底层保证切一个类的一个方法一次是好用的，可业务层各种奇葩逻辑都会有，想解耦经常用奇招所以最好允许多次切面，dispatch_once保证自己的逻辑需要的切一次就可以了，可以用我简单封装的方法。\n```\n@interface NSObject (AOPLogger)\n\n+(void)al_hookOrAddWithOriginSeletor:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector error:(NSError**)error;\n\n@end\n```\n#### 前后逻辑关联统计\n这个可以结合点击来讲，比上面还要让人头疼，类似统计我查看一个东西，要记录我在哪点击的查看以及当前页面的数据属性，还有从哪来到当前页面的，要查看东西的id。这个时候就需要结合通用统计来搞了，我们在最底层可以做的是把本身点击的UI对象的默认字典属性和最上层页面的默认字典属性以及点击对象target上层UI对象的默认字典属性做统计，最上层的激活页面这个是可以在任何地方搞出来的，回头我可以把类扩展放上来，在任何页面都可以拿到当前页面，前一个页面以及页面属于第几层。底层在响应默认点击事件之前处理我们的统计逻辑，接下来就是怎么把属性赋值，这个时候就需要我们去切面当前页面里做model赋值的方法然后同时把想要统计的属性赋值到当前页面的默认字典属性里，如果这是cell上的button那么赋值cell的时候就可以切面。\n\n总的来说就是寻找UI对象赋值点，然后切面为UI对象添加统计属性，我们runtime加到所有UI对象上隐藏的默认字典属性字段专门承接关联信息，底层只做读取整合，业务层切面赋值。\n\n这个时候就会发现数据对象与UI对象绑定协议的制定会直接决定实现的复杂度。\n#### 后序\n业务层的统计我个人认为原则上尽量后端做这个事，毕竟要保证统计数据的正确性，其实减少前端统计很重要，毕竟现在web（pc网页），wap（手机网页），小程序，安卓，ios一牵扯业务逻辑统计非常需要统一校准，不然数据绝对超乎你的想象。\n# 归纳统计解耦思路\n统计放到其他端其实解耦思路也是大致相同。。。下面总结：\n1.找底层触发的事件点\n2.业务层找赋值点\n3.使用AOP的思路对上面的地方进行插入我们的统计逻辑\n","slug":"IOS 切面统计事件解耦","published":1,"updated":"2017-08-13T20:29:28.000Z","_id":"cj6b62e0o0000u16ambzv420j","comments":1,"layout":"post","photos":[],"link":"","content":"<p>统计这个事情可以说是个巨无语的系统，当然不把他独立出来也就不是什么问题了，只是一堆牛皮癣似得代码穿插在项目各个地方，毕竟真正应用到一个app里的统计都跟业务有着很强的绑定关系，脱离业务的统计数据基本没什么大用，先吐槽一波再开始正文。。。。<br><img src=\"http://upload-images.jianshu.io/upload_images/3994053-18807a49c709e49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DingTalk20170802140347.png\"></p>\n<h1 id=\"基础封装\"><a href=\"#基础封装\" class=\"headerlink\" title=\"基础封装\"></a>基础封装</h1><p>先从用第三方的来说，基本上就只是需要包个壳就ok了，建个manager，初始化sdk一封装，加几个常用统计方法基本ok。常见的方法就是传个event名再加个properties传扩展字典，用户登录状态绑定注销，通用字段增删改，基本上这就满足了大部分需求。。。</p>\n<p>如果是纯自己手写，上面说的壳放着，剩下的仿照sdk来，基本功能要实现异步队列记录往本地写数据，定期上传，处理好读写关系是关键，这里不多说不是这篇重点。</p>\n<p>ps:有个壳才敢放开手折腾优化</p>\n<h4 id=\"切面封装\"><a href=\"#切面封装\" class=\"headerlink\" title=\"切面封装\"></a>切面封装</h4><p>切面统计其实可以看我之前的<a href=\"http://www.jianshu.com/p/a9219e618ca2\" target=\"_blank\" rel=\"external\">IOS 百行代码切面日志</a>，整个完成的就是切面的封装，看过的基本应该了解这套逻辑切面的时候不关心切面方法的参数的话会非常好用。<br>如果业务关联强的情况，虽然也能处理但要针对那些业务作出对应的逻辑，导致切面封装里夹杂很多特殊逻辑,下面的方法内部要对originAOP拆分取所有参，甚至要复制部分业务层逻辑过来最后完成一个统计。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)al_logger:(id)log originAOP:(id)originAOP</div></pre></td></tr></table></figure></p>\n<p>所以我个人建议这里就封装些简单的少参甚至无参的统计，然后基本上简单的通用统计和业务统计建个类或者plist，列一下要切面的类和方法就完成了。</p>\n<p>凡事都有特例，如果本身方法内多个参数完成一次统计就不多，那我之前的百行系列就已经足够你解耦了。</p>\n<p>ps:郑重声明AOP 至少我现在还没发现IOS里怎么实现切面静态方法（类方法）</p>\n<h1 id=\"通用统计\"><a href=\"#通用统计\" class=\"headerlink\" title=\"通用统计\"></a>通用统计</h1><p>通用统计就是可以脱离业务完全抽离的部分，这部分其实可以设计部分业务承接，比如通用点击事件可以把点击的UI对象扩展出一个字典的属性值，如此对于通用统计来说只是看看有没有某个属性有的话就扔到统计里，和业务层没有关联，但后面带来的好处很大！这个最后说。</p>\n<h4 id=\"App生命周期统计\"><a href=\"#App生命周期统计\" class=\"headerlink\" title=\"App生命周期统计\"></a>App生命周期统计</h4><p>应用生命周期的统计随便建个类，监听下面的通知就ok了，当然这个类就不能销毁了，比较懒得做法直接AOPLogger 类扩展一下init里监听，因为我本身的类里连init方法都没重写。<br><a id=\"more\"></a><br>UIApplicationDidFinishLaunchingNotification （通知名称） —&gt;   application:didFinishLaunchingWithOptions:(委托方法）：在应用程序启动后直接进行应用程序级编码的主要方式。</p>\n<p>UIApplicationWillResignActiveNotification(通知名称）—&gt;applicationWillResignActive:（委托方法）：用户按下主屏幕按钮调用 ，不要在此方法中假设将进入后台状态，只是一种临时变化，最终将恢复到活动状态</p>\n<p>UIApplicationDidBecomActiveNotification（通知名称） —-&gt;applicationDidBecomeActive:(委托方法）：应用程序按下主屏幕按钮后想要将应用程序切换到前台时调用，应用程序启动时也会调用，可以在其中添加一些应用程序初始化代码</p>\n<p>UIApplicationDidEnterBackgroundNotification(通知名称）—–&gt;applicationDidEnterBackground:（委托方法）：应用程序在此方法中释放所有可在以后重新创建的资源，保存所有用户数据，关闭网络连接等。如果需要，也可以在这里请求在后台运行更长时间。如果在这里花费了太长时间（超过5秒），系统将断定应用程序的行为异常并终止他。</p>\n<p>UIApplicationWillEnterForegroundNotification(通知名称） —-&gt;applicationWillEnterForeground:(委托方法):当应用程序在applicationDidEnterBackground:花费了太长时间，终止后，应该实现此方法来重新创建在applicationDidEnterBackground中销毁的内容，比如重新加载用户数据、重新建立网络连接等。</p>\n<p>UIApplicationWllTerminateNotification（通知名称） —-&gt; applicationWillTerminate:(委托方法):现在很少使用，只有在应用程序已进入后台，并且系统出于某种原因决定跳过暂停状态并终止应用程序时，才会真正调用它。</p>\n<h4 id=\"点击事件（不包括手势）\"><a href=\"#点击事件（不包括手势）\" class=\"headerlink\" title=\"点击事件（不包括手势）\"></a>点击事件（不包括手势）</h4><p>这里点击事件切面分为3类<br>1.UIControl的addTarget触发，UIButton都会走UIApplication里的这方法，但需要忽略一部分，不然会和第二个部分重叠，而且手势addTarget不走，不过手势不走正好可以区分手势<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>\n<p>2.设置delegate委托式系统点击触发，这里直接切了UICollectionView，UITableView，UITabBarController，UITabBar，UIAlertView，UIActionSheet这几个setDelegate方法，然后加标识判断切委托方法，用Aspects库的方法swizzing因为他不允许重复swizzing算双保险。</p>\n<p>3.UIAlertAction切block属性的set方法，每次setBlock的时候替换成我自己的block，在我的block内执行设置的block。</p>\n<p>下面就是协议，用pod的话AOPLogger/AOPClick就有了，用的时候类扩展一下AOPLogger遵守协议实现对应方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol AOPLoggerClickProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">- (void)alcp_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;</div><div class=\"line\">- (void)alcp_customIgnore_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;</div><div class=\"line\">- (void)alcp_collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;</div><div class=\"line\">- (void)alcp_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;</div><div class=\"line\">- (void)alcp_tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController from:(id)sender;</div><div class=\"line\">- (void)alcp_tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item from:(id)sender;</div><div class=\"line\">- (void)alcp_alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;</div><div class=\"line\">- (void)alcp_actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;</div><div class=\"line\">- (void)alcp_alertControllerAction:(UIAlertAction *)action from:(id)sender;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>ps:覆盖可能不全，漏了什么欢迎git提pull request</p>\n<h4 id=\"手势统计\"><a href=\"#手势统计\" class=\"headerlink\" title=\"手势统计\"></a>手势统计</h4><p>这个是切了UIView的addGestureRecognizer方法，每次添加手势的时候我多加个自己AOPLogger的taget-action到gestureRecognizer对象上，这样手势统计就搞定了。<br>如果要用这个统计点击和长按，判断一下状态是结束的时候统计gestureRecognizer类型是UITapGestureRecognizer,UILongPressGestureRecognizer就行，其实手势的统计或许都在结束的时候统计区分下类型就够了吧！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol AOPLoggerGestureRecognizerProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(void)algrp_handleGesture:(UIGestureRecognizer*)gestureRecognizer;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"页面统计\"><a href=\"#页面统计\" class=\"headerlink\" title=\"页面统计\"></a>页面统计</h4><p>这个太寻常了，感觉没什么好说，使用方法如上，之所以还提供个pod的AOPLogger/AOPPageView,主要是如果要统计浏览时长逻辑，自己方便实现（如显示的时候runtime随便塞个date进去，消失的时候算一下上报），还有我默认预先忽略了部分页面,省了自己写。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol AOPLoggerPageViewProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(BOOL)alpvp_viewIgnore:(id)sender;</div><div class=\"line\">-(void)alpvp_viewDidAppear:(BOOL)animated sender:(id)sender;</div><div class=\"line\">-(void)alpvp_viewDidDisappear:(BOOL)animated sender:(id)sender;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h1 id=\"业务统计\"><a href=\"#业务统计\" class=\"headerlink\" title=\"业务统计\"></a>业务统计</h1><p>业务统计首先放的位置要保证在对应业务线的目录里，毕竟跟业务关联密切，大的业务逻辑调整的时候看一下放业务统计目录下对应的地方需不需要修改。</p>\n<h4 id=\"无参数方法统计\"><a href=\"#无参数方法统计\" class=\"headerlink\" title=\"无参数方法统计\"></a>无参数方法统计</h4><p>这一类就是需要写在业务层里但统计的时候只记录一个Event名，比如有个方法-(void)abc:(id)a b:(id)b c:(id)c;我只是记录他被调用，这种直接AOPLogger调用下[AOPLogger AOPLoggerWithClassString:classString methodString:@”abc:b:c” log:@”abc”]或扔plist里默认直接解决。</p>\n<h4 id=\"方法内逻辑处理统计\"><a href=\"#方法内逻辑处理统计\" class=\"headerlink\" title=\"方法内逻辑处理统计\"></a>方法内逻辑处理统计</h4><p>这个就有点厉害了，比如下订单的时候我买了一堆东西里面带着各种商品属性，要你把某种属性的商品做统计，只是举例…这时候直接写这个类的类扩展load方法里切面然后写逻辑处理统计，这里不建议用Aspects库，底层保证切一个类的一个方法一次是好用的，可业务层各种奇葩逻辑都会有，想解耦经常用奇招所以最好允许多次切面，dispatch_once保证自己的逻辑需要的切一次就可以了，可以用我简单封装的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject (AOPLogger)</div><div class=\"line\"></div><div class=\"line\">+(void)al_hookOrAddWithOriginSeletor:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector error:(NSError**)error;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"前后逻辑关联统计\"><a href=\"#前后逻辑关联统计\" class=\"headerlink\" title=\"前后逻辑关联统计\"></a>前后逻辑关联统计</h4><p>这个可以结合点击来讲，比上面还要让人头疼，类似统计我查看一个东西，要记录我在哪点击的查看以及当前页面的数据属性，还有从哪来到当前页面的，要查看东西的id。这个时候就需要结合通用统计来搞了，我们在最底层可以做的是把本身点击的UI对象的默认字典属性和最上层页面的默认字典属性以及点击对象target上层UI对象的默认字典属性做统计，最上层的激活页面这个是可以在任何地方搞出来的，回头我可以把类扩展放上来，在任何页面都可以拿到当前页面，前一个页面以及页面属于第几层。底层在响应默认点击事件之前处理我们的统计逻辑，接下来就是怎么把属性赋值，这个时候就需要我们去切面当前页面里做model赋值的方法然后同时把想要统计的属性赋值到当前页面的默认字典属性里，如果这是cell上的button那么赋值cell的时候就可以切面。</p>\n<p>总的来说就是寻找UI对象赋值点，然后切面为UI对象添加统计属性，我们runtime加到所有UI对象上隐藏的默认字典属性字段专门承接关联信息，底层只做读取整合，业务层切面赋值。</p>\n<p>这个时候就会发现数据对象与UI对象绑定协议的制定会直接决定实现的复杂度。</p>\n<h4 id=\"后序\"><a href=\"#后序\" class=\"headerlink\" title=\"后序\"></a>后序</h4><p>业务层的统计我个人认为原则上尽量后端做这个事，毕竟要保证统计数据的正确性，其实减少前端统计很重要，毕竟现在web（pc网页），wap（手机网页），小程序，安卓，ios一牵扯业务逻辑统计非常需要统一校准，不然数据绝对超乎你的想象。</p>\n<h1 id=\"归纳统计解耦思路\"><a href=\"#归纳统计解耦思路\" class=\"headerlink\" title=\"归纳统计解耦思路\"></a>归纳统计解耦思路</h1><p>统计放到其他端其实解耦思路也是大致相同。。。下面总结：<br>1.找底层触发的事件点<br>2.业务层找赋值点<br>3.使用AOP的思路对上面的地方进行插入我们的统计逻辑</p>\n","site":{"data":{}},"excerpt":"<p>统计这个事情可以说是个巨无语的系统，当然不把他独立出来也就不是什么问题了，只是一堆牛皮癣似得代码穿插在项目各个地方，毕竟真正应用到一个app里的统计都跟业务有着很强的绑定关系，脱离业务的统计数据基本没什么大用，先吐槽一波再开始正文。。。。<br><img src=\"http://upload-images.jianshu.io/upload_images/3994053-18807a49c709e49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"DingTalk20170802140347.png\"></p>\n<h1 id=\"基础封装\"><a href=\"#基础封装\" class=\"headerlink\" title=\"基础封装\"></a>基础封装</h1><p>先从用第三方的来说，基本上就只是需要包个壳就ok了，建个manager，初始化sdk一封装，加几个常用统计方法基本ok。常见的方法就是传个event名再加个properties传扩展字典，用户登录状态绑定注销，通用字段增删改，基本上这就满足了大部分需求。。。</p>\n<p>如果是纯自己手写，上面说的壳放着，剩下的仿照sdk来，基本功能要实现异步队列记录往本地写数据，定期上传，处理好读写关系是关键，这里不多说不是这篇重点。</p>\n<p>ps:有个壳才敢放开手折腾优化</p>\n<h4 id=\"切面封装\"><a href=\"#切面封装\" class=\"headerlink\" title=\"切面封装\"></a>切面封装</h4><p>切面统计其实可以看我之前的<a href=\"http://www.jianshu.com/p/a9219e618ca2\" target=\"_blank\" rel=\"external\">IOS 百行代码切面日志</a>，整个完成的就是切面的封装，看过的基本应该了解这套逻辑切面的时候不关心切面方法的参数的话会非常好用。<br>如果业务关联强的情况，虽然也能处理但要针对那些业务作出对应的逻辑，导致切面封装里夹杂很多特殊逻辑,下面的方法内部要对originAOP拆分取所有参，甚至要复制部分业务层逻辑过来最后完成一个统计。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)al_logger:(id)log originAOP:(id)originAOP</div></pre></td></tr></table></figure></p>\n<p>所以我个人建议这里就封装些简单的少参甚至无参的统计，然后基本上简单的通用统计和业务统计建个类或者plist，列一下要切面的类和方法就完成了。</p>\n<p>凡事都有特例，如果本身方法内多个参数完成一次统计就不多，那我之前的百行系列就已经足够你解耦了。</p>\n<p>ps:郑重声明AOP 至少我现在还没发现IOS里怎么实现切面静态方法（类方法）</p>\n<h1 id=\"通用统计\"><a href=\"#通用统计\" class=\"headerlink\" title=\"通用统计\"></a>通用统计</h1><p>通用统计就是可以脱离业务完全抽离的部分，这部分其实可以设计部分业务承接，比如通用点击事件可以把点击的UI对象扩展出一个字典的属性值，如此对于通用统计来说只是看看有没有某个属性有的话就扔到统计里，和业务层没有关联，但后面带来的好处很大！这个最后说。</p>\n<h4 id=\"App生命周期统计\"><a href=\"#App生命周期统计\" class=\"headerlink\" title=\"App生命周期统计\"></a>App生命周期统计</h4><p>应用生命周期的统计随便建个类，监听下面的通知就ok了，当然这个类就不能销毁了，比较懒得做法直接AOPLogger 类扩展一下init里监听，因为我本身的类里连init方法都没重写。<br>","more":"<br>UIApplicationDidFinishLaunchingNotification （通知名称） —&gt;   application:didFinishLaunchingWithOptions:(委托方法）：在应用程序启动后直接进行应用程序级编码的主要方式。</p>\n<p>UIApplicationWillResignActiveNotification(通知名称）—&gt;applicationWillResignActive:（委托方法）：用户按下主屏幕按钮调用 ，不要在此方法中假设将进入后台状态，只是一种临时变化，最终将恢复到活动状态</p>\n<p>UIApplicationDidBecomActiveNotification（通知名称） —-&gt;applicationDidBecomeActive:(委托方法）：应用程序按下主屏幕按钮后想要将应用程序切换到前台时调用，应用程序启动时也会调用，可以在其中添加一些应用程序初始化代码</p>\n<p>UIApplicationDidEnterBackgroundNotification(通知名称）—–&gt;applicationDidEnterBackground:（委托方法）：应用程序在此方法中释放所有可在以后重新创建的资源，保存所有用户数据，关闭网络连接等。如果需要，也可以在这里请求在后台运行更长时间。如果在这里花费了太长时间（超过5秒），系统将断定应用程序的行为异常并终止他。</p>\n<p>UIApplicationWillEnterForegroundNotification(通知名称） —-&gt;applicationWillEnterForeground:(委托方法):当应用程序在applicationDidEnterBackground:花费了太长时间，终止后，应该实现此方法来重新创建在applicationDidEnterBackground中销毁的内容，比如重新加载用户数据、重新建立网络连接等。</p>\n<p>UIApplicationWllTerminateNotification（通知名称） —-&gt; applicationWillTerminate:(委托方法):现在很少使用，只有在应用程序已进入后台，并且系统出于某种原因决定跳过暂停状态并终止应用程序时，才会真正调用它。</p>\n<h4 id=\"点击事件（不包括手势）\"><a href=\"#点击事件（不包括手势）\" class=\"headerlink\" title=\"点击事件（不包括手势）\"></a>点击事件（不包括手势）</h4><p>这里点击事件切面分为3类<br>1.UIControl的addTarget触发，UIButton都会走UIApplication里的这方法，但需要忽略一部分，不然会和第二个部分重叠，而且手势addTarget不走，不过手势不走正好可以区分手势<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>\n<p>2.设置delegate委托式系统点击触发，这里直接切了UICollectionView，UITableView，UITabBarController，UITabBar，UIAlertView，UIActionSheet这几个setDelegate方法，然后加标识判断切委托方法，用Aspects库的方法swizzing因为他不允许重复swizzing算双保险。</p>\n<p>3.UIAlertAction切block属性的set方法，每次setBlock的时候替换成我自己的block，在我的block内执行设置的block。</p>\n<p>下面就是协议，用pod的话AOPLogger/AOPClick就有了，用的时候类扩展一下AOPLogger遵守协议实现对应方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol AOPLoggerClickProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">- (void)alcp_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;</div><div class=\"line\">- (void)alcp_customIgnore_sendAction:(SEL)action to:(id)target from:(id)sender forEvent:(UIEvent *)event;</div><div class=\"line\">- (void)alcp_collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;</div><div class=\"line\">- (void)alcp_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath from:(id)sender;</div><div class=\"line\">- (void)alcp_tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController from:(id)sender;</div><div class=\"line\">- (void)alcp_tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item from:(id)sender;</div><div class=\"line\">- (void)alcp_alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;</div><div class=\"line\">- (void)alcp_actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex from:(id)sender;</div><div class=\"line\">- (void)alcp_alertControllerAction:(UIAlertAction *)action from:(id)sender;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>ps:覆盖可能不全，漏了什么欢迎git提pull request</p>\n<h4 id=\"手势统计\"><a href=\"#手势统计\" class=\"headerlink\" title=\"手势统计\"></a>手势统计</h4><p>这个是切了UIView的addGestureRecognizer方法，每次添加手势的时候我多加个自己AOPLogger的taget-action到gestureRecognizer对象上，这样手势统计就搞定了。<br>如果要用这个统计点击和长按，判断一下状态是结束的时候统计gestureRecognizer类型是UITapGestureRecognizer,UILongPressGestureRecognizer就行，其实手势的统计或许都在结束的时候统计区分下类型就够了吧！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol AOPLoggerGestureRecognizerProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(void)algrp_handleGesture:(UIGestureRecognizer*)gestureRecognizer;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"页面统计\"><a href=\"#页面统计\" class=\"headerlink\" title=\"页面统计\"></a>页面统计</h4><p>这个太寻常了，感觉没什么好说，使用方法如上，之所以还提供个pod的AOPLogger/AOPPageView,主要是如果要统计浏览时长逻辑，自己方便实现（如显示的时候runtime随便塞个date进去，消失的时候算一下上报），还有我默认预先忽略了部分页面,省了自己写。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol AOPLoggerPageViewProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(BOOL)alpvp_viewIgnore:(id)sender;</div><div class=\"line\">-(void)alpvp_viewDidAppear:(BOOL)animated sender:(id)sender;</div><div class=\"line\">-(void)alpvp_viewDidDisappear:(BOOL)animated sender:(id)sender;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h1 id=\"业务统计\"><a href=\"#业务统计\" class=\"headerlink\" title=\"业务统计\"></a>业务统计</h1><p>业务统计首先放的位置要保证在对应业务线的目录里，毕竟跟业务关联密切，大的业务逻辑调整的时候看一下放业务统计目录下对应的地方需不需要修改。</p>\n<h4 id=\"无参数方法统计\"><a href=\"#无参数方法统计\" class=\"headerlink\" title=\"无参数方法统计\"></a>无参数方法统计</h4><p>这一类就是需要写在业务层里但统计的时候只记录一个Event名，比如有个方法-(void)abc:(id)a b:(id)b c:(id)c;我只是记录他被调用，这种直接AOPLogger调用下[AOPLogger AOPLoggerWithClassString:classString methodString:@”abc:b:c” log:@”abc”]或扔plist里默认直接解决。</p>\n<h4 id=\"方法内逻辑处理统计\"><a href=\"#方法内逻辑处理统计\" class=\"headerlink\" title=\"方法内逻辑处理统计\"></a>方法内逻辑处理统计</h4><p>这个就有点厉害了，比如下订单的时候我买了一堆东西里面带着各种商品属性，要你把某种属性的商品做统计，只是举例…这时候直接写这个类的类扩展load方法里切面然后写逻辑处理统计，这里不建议用Aspects库，底层保证切一个类的一个方法一次是好用的，可业务层各种奇葩逻辑都会有，想解耦经常用奇招所以最好允许多次切面，dispatch_once保证自己的逻辑需要的切一次就可以了，可以用我简单封装的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject (AOPLogger)</div><div class=\"line\"></div><div class=\"line\">+(void)al_hookOrAddWithOriginSeletor:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector error:(NSError**)error;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"前后逻辑关联统计\"><a href=\"#前后逻辑关联统计\" class=\"headerlink\" title=\"前后逻辑关联统计\"></a>前后逻辑关联统计</h4><p>这个可以结合点击来讲，比上面还要让人头疼，类似统计我查看一个东西，要记录我在哪点击的查看以及当前页面的数据属性，还有从哪来到当前页面的，要查看东西的id。这个时候就需要结合通用统计来搞了，我们在最底层可以做的是把本身点击的UI对象的默认字典属性和最上层页面的默认字典属性以及点击对象target上层UI对象的默认字典属性做统计，最上层的激活页面这个是可以在任何地方搞出来的，回头我可以把类扩展放上来，在任何页面都可以拿到当前页面，前一个页面以及页面属于第几层。底层在响应默认点击事件之前处理我们的统计逻辑，接下来就是怎么把属性赋值，这个时候就需要我们去切面当前页面里做model赋值的方法然后同时把想要统计的属性赋值到当前页面的默认字典属性里，如果这是cell上的button那么赋值cell的时候就可以切面。</p>\n<p>总的来说就是寻找UI对象赋值点，然后切面为UI对象添加统计属性，我们runtime加到所有UI对象上隐藏的默认字典属性字段专门承接关联信息，底层只做读取整合，业务层切面赋值。</p>\n<p>这个时候就会发现数据对象与UI对象绑定协议的制定会直接决定实现的复杂度。</p>\n<h4 id=\"后序\"><a href=\"#后序\" class=\"headerlink\" title=\"后序\"></a>后序</h4><p>业务层的统计我个人认为原则上尽量后端做这个事，毕竟要保证统计数据的正确性，其实减少前端统计很重要，毕竟现在web（pc网页），wap（手机网页），小程序，安卓，ios一牵扯业务逻辑统计非常需要统一校准，不然数据绝对超乎你的想象。</p>\n<h1 id=\"归纳统计解耦思路\"><a href=\"#归纳统计解耦思路\" class=\"headerlink\" title=\"归纳统计解耦思路\"></a>归纳统计解耦思路</h1><p>统计放到其他端其实解耦思路也是大致相同。。。下面总结：<br>1.找底层触发的事件点<br>2.业务层找赋值点<br>3.使用AOP的思路对上面的地方进行插入我们的统计逻辑</p>"},{"title":"IOS 百行代码切面日志","date":"2017-03-21T18:09:05.000Z","_content":"\n# AOPLogger\n### 切面日志作用\n说到日志，切面的实现最大的好处也就是分离出来，单独开发，包括埋点，记录输出log都可以在不影响项目内逻辑的情况下完成，形成完全的一个独立模块。\n#### 这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\n\n\n在实现上用了Aspects这个库，主要就是hook方法，用它主要是对一些例外情况处理不错，自己写简单实现其实就只写写方法交换剩下的就不管了。。。\n\n下面说一下.h\n```Objective-C\n#import <Foundation/Foundation.h>\n\nextern NSString * const AOPLoggerMethod;//要统计的日志方法Key\nextern NSString * const AOPLoggerLogInfo;//要统计的日志信息Key\nextern NSString * const AOPLoggerPositionAfter;//方法执行后统计日志\nextern NSString * const AOPLoggerPositionBefore;//方法执行前统计日志\nextern NSString * const AOPLoggerPositionType;//执行日志统计的类型Key\n\n@protocol AOPLoggerGetConfigInfoProtocol <NSObject>\n\n@required\n\n/**\n创建类扩展如果使用此协议必须实现此方法\n此方法返回统计的配置信息，可以从网络取也可以从本地取\n@return 统计配置字典\n*/\n-(NSDictionary*)al_getConfigInfo;\n\n@end\n@protocol AOPLoggerBLLProtocol <NSObject>\n\n@required\n\n/**\n创建类扩展如果使用此协议必须实现此方法\n此方法主要来处理切面方法后的log信息处理可以存本地也可以使用其他任意第三方输出\n@param log 配置文件里定义的AOPLoggerLogInfo信息\n@param originAOP AspectInfo的方法信息，第三方库Aspect返回的切面方法的所有信息\n*/\n-(void)al_logger:(id)log originAOP:(id)originAOP;\n\n@end\n\n@interface AOPLogger : NSObject\n\n\n/**\n开始读取日志Plist配置文件\n*/\n+(void)startAOPLoggerWithPlist;\n\n/**\n统计日志的调用方法\n（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）\n@param classString 类名\n@param methodString 方法名\n@param log 相当于AOPLoggerLogInfo信息\n*/\n+(void)AOPLoggerWithClassString:(NSString*)classString methodString:(NSString*)methodString log:(id)log;\n\n/**\n统计日志的调用方法\n（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）\n@param classString 类名\n@param methodString 方法名\n@param log 相当于AOPLoggerLogInfo信息\n@param logPosition 日志统计时位置，可放在方法运行前或运行后（默认运行后执行日志统计）\n*/\n+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition;\n\n@end\n```\n<!-- more -->\n这里提供了两种方式一种直接读取自定义的Plist，一种就是调用类方法，而即使调用类方法，也是单独建一个类，某个模块的日志类负责记录，传入类名方法名统计信息即可，而plist得形式在初期还好，后期统计曾多可就真的太扯了毕竟要在初始化的时候加载遍历执行\n![QQ20170306-012628.png](http://upload-images.jianshu.io/upload_images/3994053-46f6bef1c87511f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 定制扩展\n由于每个项目想要做的事情或逻辑都会有不同，这里就可以根据我的协议实现对应的方法，来完成自己的业务需求\n如下：\n```Objective-C\nimport \"AOPLogger+Custom.h\"\n#import \"Aspects.h\"\n#import <objc/runtime.h>\n\n@implementation AOPLogger (Custom)\n\n-(void)al_logger:(id)log originAOP:(id)originAOP{\nif ([log isKindOfClass:[NSString class]]) {\nNSLog(@\"event:%@\",log);\n}\nif ([log isKindOfClass:[NSDictionary class]]) {\nNSLog(@\"eventName:%@\\neventLabel:%@\\neventTime:%@\",log[@\"EventName\"],log[@\"EventLabel\"],[log[@\"EventTime\"] boolValue]?[NSDate date]:@\"不用获取\");\n}\nif (originAOP&&[originAOP conformsToProtocol:objc_getProtocol(\"AspectInfo\")]) {\nid<AspectInfo> aspectInfo=originAOP;\nNSLog(@\"originClass:%@\\noriginSel:%@\",NSStringFromClass([aspectInfo.originalInvocation.target class]),NSStringFromSelector(aspectInfo.originalInvocation.selector));\n\nfor (NSInteger i=0; i<aspectInfo.arguments.count; i++) {\nNSLog(@\"argument:%@\",aspectInfo.arguments[i]);\n}\n}\n}\n\n@end\n```\n这里只是做了简单的NSLog操作，而当某个业务模块下需要不同处理的时候，不妨就直接hook这个方法添加逻辑，用法完全靠个人想像吧，其实用起来经常能处理很多神奇的逻辑，里面的originAOP如果用过Aspects这个库的话可能会很快明白为什么要选这个库不是自己写了，因为它的这块封装可以让我拿到对应方法执行完后返回的值，当然你得指定这个log是在原方法执行完成后执行，同理如果放在执行前执行log我们通过这个对象还可以拿到方法传递的参数。\n\n再看.m的源码\n```Objective-C\n#import \"AOPLogger.h\"\n#import \"Aspects.h\"\n#import <objc/runtime.h>\n\nNSString * const AOPLoggerMethod=@\"AOPLoggerMethod\";\nNSString * const AOPLoggerLogInfo=@\"AOPLoggerLogInfo\";\nNSString * const AOPLoggerPositionAfter=@\"AOPLoggerPositionAfter\";\nNSString * const AOPLoggerPositionBefore=@\"AOPLoggerPositionBefore\";\nNSString * const AOPLoggerPositionType=@\"AOPLoggerPositionType\";\n\n@implementation AOPLogger\n\n+ (AOPLogger *)sharedAOPLogger {\nstatic AOPLogger *sharedAOPLogger = nil;\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\nsharedAOPLogger = [[self alloc] init];\n});\nreturn sharedAOPLogger;\n}\n\n+(void)startAOPLoggerWithPlist{\nNSDictionary *loggerConfigInfo=nil;\nif ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(\"AOPLoggerGetConfigInfoProtocol\")]) {\nloggerConfigInfo=[(AOPLogger<AOPLoggerGetConfigInfoProtocol>*)[AOPLogger sharedAOPLogger] al_getConfigInfo];\n}\nelse{\nloggerConfigInfo=[NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"AOPLoggerConfig\" ofType:@\"plist\"]];\n}\n\nfor (NSString *className in loggerConfigInfo) {\nfor (NSDictionary *eventInfo in loggerConfigInfo[className]) {\nClass clazz = NSClassFromString(className);\nSEL selector = NSSelectorFromString(eventInfo[AOPLoggerMethod]);\nAspectOptions positionOptions=AspectPositionAfter;\nif ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionAfter]) {\npositionOptions=AspectPositionAfter;\n}\nif ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionBefore]) {\npositionOptions=AspectPositionBefore;\n}\n\n[clazz aspect_hookSelector:selector\nwithOptions:AspectPositionAfter\nusingBlock:^(id<AspectInfo> aspectInfo) {\nid log=eventInfo[AOPLoggerLogInfo];\n\nif ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(\"AOPLoggerBLLProtocol\")]) {\n[(AOPLogger<AOPLoggerBLLProtocol>*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];\n}\nelse{\nif ([log isKindOfClass:[NSString class]]) {\nNSLog(@\"AOPLogger:%@\",log);\n}\n}\n} error:NULL];\n\n}\n}\n\n}\n\n+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log{\n[self AOPLoggerWithClassString:classString methodString:methodString log:log logPosition:nil];\n}\n\n+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition{\nClass clazz = NSClassFromString(classString);\nSEL selector = NSSelectorFromString(methodString);\nAspectOptions positionOptions=AspectPositionAfter;\nif ([logPosition isEqualToString:AOPLoggerPositionAfter]) {\npositionOptions=AspectPositionAfter;\n}\nif ([logPosition isEqualToString:AOPLoggerPositionBefore]) {\npositionOptions=AspectPositionBefore;\n}\n\n[clazz aspect_hookSelector:selector\nwithOptions:positionOptions\nusingBlock:^(id<AspectInfo> aspectInfo) {\nif ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(\"AOPLoggerBLLProtocol\")]) {\n[(AOPLogger<AOPLoggerBLLProtocol>*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];\n}\nelse{\nif ([log isKindOfClass:[NSString class]]) {\nNSLog(@\"AOPLogger:%@\",log);\n}\n}\n} error:NULL];\n\n}\n```\n核心处理.m直接不到百行，主要逻辑就是 单例初始化， 读取plist并格式化出执行的类 ·方法·log信息，最后就是利用AOP,切面hook对应方法插入我们统计逻辑。\n\n有了这个库完全可以日志动态话统计，前提你要做好热更新或使用plist形式。\n\n源码地址：https://github.com/heroims/AOPLogger\n","source":"_posts/IOS 百行代码切面日志.md","raw":"---\ntitle: IOS 百行代码切面日志\ndate: 2017-03-22 02:09:05\ntags:\n---\n\n# AOPLogger\n### 切面日志作用\n说到日志，切面的实现最大的好处也就是分离出来，单独开发，包括埋点，记录输出log都可以在不影响项目内逻辑的情况下完成，形成完全的一个独立模块。\n#### 这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\n\n\n在实现上用了Aspects这个库，主要就是hook方法，用它主要是对一些例外情况处理不错，自己写简单实现其实就只写写方法交换剩下的就不管了。。。\n\n下面说一下.h\n```Objective-C\n#import <Foundation/Foundation.h>\n\nextern NSString * const AOPLoggerMethod;//要统计的日志方法Key\nextern NSString * const AOPLoggerLogInfo;//要统计的日志信息Key\nextern NSString * const AOPLoggerPositionAfter;//方法执行后统计日志\nextern NSString * const AOPLoggerPositionBefore;//方法执行前统计日志\nextern NSString * const AOPLoggerPositionType;//执行日志统计的类型Key\n\n@protocol AOPLoggerGetConfigInfoProtocol <NSObject>\n\n@required\n\n/**\n创建类扩展如果使用此协议必须实现此方法\n此方法返回统计的配置信息，可以从网络取也可以从本地取\n@return 统计配置字典\n*/\n-(NSDictionary*)al_getConfigInfo;\n\n@end\n@protocol AOPLoggerBLLProtocol <NSObject>\n\n@required\n\n/**\n创建类扩展如果使用此协议必须实现此方法\n此方法主要来处理切面方法后的log信息处理可以存本地也可以使用其他任意第三方输出\n@param log 配置文件里定义的AOPLoggerLogInfo信息\n@param originAOP AspectInfo的方法信息，第三方库Aspect返回的切面方法的所有信息\n*/\n-(void)al_logger:(id)log originAOP:(id)originAOP;\n\n@end\n\n@interface AOPLogger : NSObject\n\n\n/**\n开始读取日志Plist配置文件\n*/\n+(void)startAOPLoggerWithPlist;\n\n/**\n统计日志的调用方法\n（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）\n@param classString 类名\n@param methodString 方法名\n@param log 相当于AOPLoggerLogInfo信息\n*/\n+(void)AOPLoggerWithClassString:(NSString*)classString methodString:(NSString*)methodString log:(id)log;\n\n/**\n统计日志的调用方法\n（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）\n@param classString 类名\n@param methodString 方法名\n@param log 相当于AOPLoggerLogInfo信息\n@param logPosition 日志统计时位置，可放在方法运行前或运行后（默认运行后执行日志统计）\n*/\n+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition;\n\n@end\n```\n<!-- more -->\n这里提供了两种方式一种直接读取自定义的Plist，一种就是调用类方法，而即使调用类方法，也是单独建一个类，某个模块的日志类负责记录，传入类名方法名统计信息即可，而plist得形式在初期还好，后期统计曾多可就真的太扯了毕竟要在初始化的时候加载遍历执行\n![QQ20170306-012628.png](http://upload-images.jianshu.io/upload_images/3994053-46f6bef1c87511f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 定制扩展\n由于每个项目想要做的事情或逻辑都会有不同，这里就可以根据我的协议实现对应的方法，来完成自己的业务需求\n如下：\n```Objective-C\nimport \"AOPLogger+Custom.h\"\n#import \"Aspects.h\"\n#import <objc/runtime.h>\n\n@implementation AOPLogger (Custom)\n\n-(void)al_logger:(id)log originAOP:(id)originAOP{\nif ([log isKindOfClass:[NSString class]]) {\nNSLog(@\"event:%@\",log);\n}\nif ([log isKindOfClass:[NSDictionary class]]) {\nNSLog(@\"eventName:%@\\neventLabel:%@\\neventTime:%@\",log[@\"EventName\"],log[@\"EventLabel\"],[log[@\"EventTime\"] boolValue]?[NSDate date]:@\"不用获取\");\n}\nif (originAOP&&[originAOP conformsToProtocol:objc_getProtocol(\"AspectInfo\")]) {\nid<AspectInfo> aspectInfo=originAOP;\nNSLog(@\"originClass:%@\\noriginSel:%@\",NSStringFromClass([aspectInfo.originalInvocation.target class]),NSStringFromSelector(aspectInfo.originalInvocation.selector));\n\nfor (NSInteger i=0; i<aspectInfo.arguments.count; i++) {\nNSLog(@\"argument:%@\",aspectInfo.arguments[i]);\n}\n}\n}\n\n@end\n```\n这里只是做了简单的NSLog操作，而当某个业务模块下需要不同处理的时候，不妨就直接hook这个方法添加逻辑，用法完全靠个人想像吧，其实用起来经常能处理很多神奇的逻辑，里面的originAOP如果用过Aspects这个库的话可能会很快明白为什么要选这个库不是自己写了，因为它的这块封装可以让我拿到对应方法执行完后返回的值，当然你得指定这个log是在原方法执行完成后执行，同理如果放在执行前执行log我们通过这个对象还可以拿到方法传递的参数。\n\n再看.m的源码\n```Objective-C\n#import \"AOPLogger.h\"\n#import \"Aspects.h\"\n#import <objc/runtime.h>\n\nNSString * const AOPLoggerMethod=@\"AOPLoggerMethod\";\nNSString * const AOPLoggerLogInfo=@\"AOPLoggerLogInfo\";\nNSString * const AOPLoggerPositionAfter=@\"AOPLoggerPositionAfter\";\nNSString * const AOPLoggerPositionBefore=@\"AOPLoggerPositionBefore\";\nNSString * const AOPLoggerPositionType=@\"AOPLoggerPositionType\";\n\n@implementation AOPLogger\n\n+ (AOPLogger *)sharedAOPLogger {\nstatic AOPLogger *sharedAOPLogger = nil;\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\nsharedAOPLogger = [[self alloc] init];\n});\nreturn sharedAOPLogger;\n}\n\n+(void)startAOPLoggerWithPlist{\nNSDictionary *loggerConfigInfo=nil;\nif ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(\"AOPLoggerGetConfigInfoProtocol\")]) {\nloggerConfigInfo=[(AOPLogger<AOPLoggerGetConfigInfoProtocol>*)[AOPLogger sharedAOPLogger] al_getConfigInfo];\n}\nelse{\nloggerConfigInfo=[NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"AOPLoggerConfig\" ofType:@\"plist\"]];\n}\n\nfor (NSString *className in loggerConfigInfo) {\nfor (NSDictionary *eventInfo in loggerConfigInfo[className]) {\nClass clazz = NSClassFromString(className);\nSEL selector = NSSelectorFromString(eventInfo[AOPLoggerMethod]);\nAspectOptions positionOptions=AspectPositionAfter;\nif ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionAfter]) {\npositionOptions=AspectPositionAfter;\n}\nif ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionBefore]) {\npositionOptions=AspectPositionBefore;\n}\n\n[clazz aspect_hookSelector:selector\nwithOptions:AspectPositionAfter\nusingBlock:^(id<AspectInfo> aspectInfo) {\nid log=eventInfo[AOPLoggerLogInfo];\n\nif ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(\"AOPLoggerBLLProtocol\")]) {\n[(AOPLogger<AOPLoggerBLLProtocol>*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];\n}\nelse{\nif ([log isKindOfClass:[NSString class]]) {\nNSLog(@\"AOPLogger:%@\",log);\n}\n}\n} error:NULL];\n\n}\n}\n\n}\n\n+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log{\n[self AOPLoggerWithClassString:classString methodString:methodString log:log logPosition:nil];\n}\n\n+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition{\nClass clazz = NSClassFromString(classString);\nSEL selector = NSSelectorFromString(methodString);\nAspectOptions positionOptions=AspectPositionAfter;\nif ([logPosition isEqualToString:AOPLoggerPositionAfter]) {\npositionOptions=AspectPositionAfter;\n}\nif ([logPosition isEqualToString:AOPLoggerPositionBefore]) {\npositionOptions=AspectPositionBefore;\n}\n\n[clazz aspect_hookSelector:selector\nwithOptions:positionOptions\nusingBlock:^(id<AspectInfo> aspectInfo) {\nif ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(\"AOPLoggerBLLProtocol\")]) {\n[(AOPLogger<AOPLoggerBLLProtocol>*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];\n}\nelse{\nif ([log isKindOfClass:[NSString class]]) {\nNSLog(@\"AOPLogger:%@\",log);\n}\n}\n} error:NULL];\n\n}\n```\n核心处理.m直接不到百行，主要逻辑就是 单例初始化， 读取plist并格式化出执行的类 ·方法·log信息，最后就是利用AOP,切面hook对应方法插入我们统计逻辑。\n\n有了这个库完全可以日志动态话统计，前提你要做好热更新或使用plist形式。\n\n源码地址：https://github.com/heroims/AOPLogger\n","slug":"IOS 百行代码切面日志","published":1,"updated":"2017-08-13T20:28:51.000Z","_id":"cj6b62e0u0001u16a29jy8pj7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"AOPLogger\"><a href=\"#AOPLogger\" class=\"headerlink\" title=\"AOPLogger\"></a>AOPLogger</h1><h3 id=\"切面日志作用\"><a href=\"#切面日志作用\" class=\"headerlink\" title=\"切面日志作用\"></a>切面日志作用</h3><p>说到日志，切面的实现最大的好处也就是分离出来，单独开发，包括埋点，记录输出log都可以在不影响项目内逻辑的情况下完成，形成完全的一个独立模块。</p>\n<h4 id=\"这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\"><a href=\"#这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\" class=\"headerlink\" title=\"这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\"></a>这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。</h4><p>在实现上用了Aspects这个库，主要就是hook方法，用它主要是对一些例外情况处理不错，自己写简单实现其实就只写写方法交换剩下的就不管了。。。</p>\n<p>下面说一下.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">extern NSString * const AOPLoggerMethod;//要统计的日志方法Key</div><div class=\"line\">extern NSString * const AOPLoggerLogInfo;//要统计的日志信息Key</div><div class=\"line\">extern NSString * const AOPLoggerPositionAfter;//方法执行后统计日志</div><div class=\"line\">extern NSString * const AOPLoggerPositionBefore;//方法执行前统计日志</div><div class=\"line\">extern NSString * const AOPLoggerPositionType;//执行日志统计的类型Key</div><div class=\"line\"></div><div class=\"line\">@protocol AOPLoggerGetConfigInfoProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">创建类扩展如果使用此协议必须实现此方法</div><div class=\"line\">此方法返回统计的配置信息，可以从网络取也可以从本地取</div><div class=\"line\">@return 统计配置字典</div><div class=\"line\">*/</div><div class=\"line\">-(NSDictionary*)al_getConfigInfo;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@protocol AOPLoggerBLLProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">创建类扩展如果使用此协议必须实现此方法</div><div class=\"line\">此方法主要来处理切面方法后的log信息处理可以存本地也可以使用其他任意第三方输出</div><div class=\"line\">@param log 配置文件里定义的AOPLoggerLogInfo信息</div><div class=\"line\">@param originAOP AspectInfo的方法信息，第三方库Aspect返回的切面方法的所有信息</div><div class=\"line\">*/</div><div class=\"line\">-(void)al_logger:(id)log originAOP:(id)originAOP;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface AOPLogger : NSObject</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">开始读取日志Plist配置文件</div><div class=\"line\">*/</div><div class=\"line\">+(void)startAOPLoggerWithPlist;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">统计日志的调用方法</div><div class=\"line\">（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）</div><div class=\"line\">@param classString 类名</div><div class=\"line\">@param methodString 方法名</div><div class=\"line\">@param log 相当于AOPLoggerLogInfo信息</div><div class=\"line\">*/</div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString*)classString methodString:(NSString*)methodString log:(id)log;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">统计日志的调用方法</div><div class=\"line\">（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）</div><div class=\"line\">@param classString 类名</div><div class=\"line\">@param methodString 方法名</div><div class=\"line\">@param log 相当于AOPLoggerLogInfo信息</div><div class=\"line\">@param logPosition 日志统计时位置，可放在方法运行前或运行后（默认运行后执行日志统计）</div><div class=\"line\">*/</div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>这里提供了两种方式一种直接读取自定义的Plist，一种就是调用类方法，而即使调用类方法，也是单独建一个类，某个模块的日志类负责记录，传入类名方法名统计信息即可，而plist得形式在初期还好，后期统计曾多可就真的太扯了毕竟要在初始化的时候加载遍历执行<br><img src=\"http://upload-images.jianshu.io/upload_images/3994053-46f6bef1c87511f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20170306-012628.png\"></p>\n<h1 id=\"定制扩展\"><a href=\"#定制扩展\" class=\"headerlink\" title=\"定制扩展\"></a>定制扩展</h1><p>由于每个项目想要做的事情或逻辑都会有不同，这里就可以根据我的协议实现对应的方法，来完成自己的业务需求<br>如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &quot;AOPLogger+Custom.h&quot;</div><div class=\"line\">#import &quot;Aspects.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation AOPLogger (Custom)</div><div class=\"line\"></div><div class=\"line\">-(void)al_logger:(id)log originAOP:(id)originAOP&#123;</div><div class=\"line\">if ([log isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">NSLog(@&quot;event:%@&quot;,log);</div><div class=\"line\">&#125;</div><div class=\"line\">if ([log isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">NSLog(@&quot;eventName:%@\\neventLabel:%@\\neventTime:%@&quot;,log[@&quot;EventName&quot;],log[@&quot;EventLabel&quot;],[log[@&quot;EventTime&quot;] boolValue]?[NSDate date]:@&quot;不用获取&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">if (originAOP&amp;&amp;[originAOP conformsToProtocol:objc_getProtocol(&quot;AspectInfo&quot;)]) &#123;</div><div class=\"line\">id&lt;AspectInfo&gt; aspectInfo=originAOP;</div><div class=\"line\">NSLog(@&quot;originClass:%@\\noriginSel:%@&quot;,NSStringFromClass([aspectInfo.originalInvocation.target class]),NSStringFromSelector(aspectInfo.originalInvocation.selector));</div><div class=\"line\"></div><div class=\"line\">for (NSInteger i=0; i&lt;aspectInfo.arguments.count; i++) &#123;</div><div class=\"line\">NSLog(@&quot;argument:%@&quot;,aspectInfo.arguments[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>这里只是做了简单的NSLog操作，而当某个业务模块下需要不同处理的时候，不妨就直接hook这个方法添加逻辑，用法完全靠个人想像吧，其实用起来经常能处理很多神奇的逻辑，里面的originAOP如果用过Aspects这个库的话可能会很快明白为什么要选这个库不是自己写了，因为它的这块封装可以让我拿到对应方法执行完后返回的值，当然你得指定这个log是在原方法执行完成后执行，同理如果放在执行前执行log我们通过这个对象还可以拿到方法传递的参数。</p>\n<p>再看.m的源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;AOPLogger.h&quot;</div><div class=\"line\">#import &quot;Aspects.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">NSString * const AOPLoggerMethod=@&quot;AOPLoggerMethod&quot;;</div><div class=\"line\">NSString * const AOPLoggerLogInfo=@&quot;AOPLoggerLogInfo&quot;;</div><div class=\"line\">NSString * const AOPLoggerPositionAfter=@&quot;AOPLoggerPositionAfter&quot;;</div><div class=\"line\">NSString * const AOPLoggerPositionBefore=@&quot;AOPLoggerPositionBefore&quot;;</div><div class=\"line\">NSString * const AOPLoggerPositionType=@&quot;AOPLoggerPositionType&quot;;</div><div class=\"line\"></div><div class=\"line\">@implementation AOPLogger</div><div class=\"line\"></div><div class=\"line\">+ (AOPLogger *)sharedAOPLogger &#123;</div><div class=\"line\">static AOPLogger *sharedAOPLogger = nil;</div><div class=\"line\">static dispatch_once_t onceToken;</div><div class=\"line\">dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">sharedAOPLogger = [[self alloc] init];</div><div class=\"line\">&#125;);</div><div class=\"line\">return sharedAOPLogger;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)startAOPLoggerWithPlist&#123;</div><div class=\"line\">NSDictionary *loggerConfigInfo=nil;</div><div class=\"line\">if ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(&quot;AOPLoggerGetConfigInfoProtocol&quot;)]) &#123;</div><div class=\"line\">loggerConfigInfo=[(AOPLogger&lt;AOPLoggerGetConfigInfoProtocol&gt;*)[AOPLogger sharedAOPLogger] al_getConfigInfo];</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">loggerConfigInfo=[NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;AOPLoggerConfig&quot; ofType:@&quot;plist&quot;]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for (NSString *className in loggerConfigInfo) &#123;</div><div class=\"line\">for (NSDictionary *eventInfo in loggerConfigInfo[className]) &#123;</div><div class=\"line\">Class clazz = NSClassFromString(className);</div><div class=\"line\">SEL selector = NSSelectorFromString(eventInfo[AOPLoggerMethod]);</div><div class=\"line\">AspectOptions positionOptions=AspectPositionAfter;</div><div class=\"line\">if ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionAfter]) &#123;</div><div class=\"line\">positionOptions=AspectPositionAfter;</div><div class=\"line\">&#125;</div><div class=\"line\">if ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionBefore]) &#123;</div><div class=\"line\">positionOptions=AspectPositionBefore;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[clazz aspect_hookSelector:selector</div><div class=\"line\">withOptions:AspectPositionAfter</div><div class=\"line\">usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class=\"line\">id log=eventInfo[AOPLoggerLogInfo];</div><div class=\"line\"></div><div class=\"line\">if ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(&quot;AOPLoggerBLLProtocol&quot;)]) &#123;</div><div class=\"line\">[(AOPLogger&lt;AOPLoggerBLLProtocol&gt;*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">if ([log isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">NSLog(@&quot;AOPLogger:%@&quot;,log);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; error:NULL];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log&#123;</div><div class=\"line\">[self AOPLoggerWithClassString:classString methodString:methodString log:log logPosition:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition&#123;</div><div class=\"line\">Class clazz = NSClassFromString(classString);</div><div class=\"line\">SEL selector = NSSelectorFromString(methodString);</div><div class=\"line\">AspectOptions positionOptions=AspectPositionAfter;</div><div class=\"line\">if ([logPosition isEqualToString:AOPLoggerPositionAfter]) &#123;</div><div class=\"line\">positionOptions=AspectPositionAfter;</div><div class=\"line\">&#125;</div><div class=\"line\">if ([logPosition isEqualToString:AOPLoggerPositionBefore]) &#123;</div><div class=\"line\">positionOptions=AspectPositionBefore;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[clazz aspect_hookSelector:selector</div><div class=\"line\">withOptions:positionOptions</div><div class=\"line\">usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class=\"line\">if ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(&quot;AOPLoggerBLLProtocol&quot;)]) &#123;</div><div class=\"line\">[(AOPLogger&lt;AOPLoggerBLLProtocol&gt;*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">if ([log isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">NSLog(@&quot;AOPLogger:%@&quot;,log);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; error:NULL];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>核心处理.m直接不到百行，主要逻辑就是 单例初始化， 读取plist并格式化出执行的类 ·方法·log信息，最后就是利用AOP,切面hook对应方法插入我们统计逻辑。</p>\n<p>有了这个库完全可以日志动态话统计，前提你要做好热更新或使用plist形式。</p>\n<p>源码地址：<a href=\"https://github.com/heroims/AOPLogger\" target=\"_blank\" rel=\"external\">https://github.com/heroims/AOPLogger</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"AOPLogger\"><a href=\"#AOPLogger\" class=\"headerlink\" title=\"AOPLogger\"></a>AOPLogger</h1><h3 id=\"切面日志作用\"><a href=\"#切面日志作用\" class=\"headerlink\" title=\"切面日志作用\"></a>切面日志作用</h3><p>说到日志，切面的实现最大的好处也就是分离出来，单独开发，包括埋点，记录输出log都可以在不影响项目内逻辑的情况下完成，形成完全的一个独立模块。</p>\n<h4 id=\"这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\"><a href=\"#这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\" class=\"headerlink\" title=\"这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。\"></a>这里的切面日志，只是作为分离业务而用，所以它的作用只是记录，至于上传删除，这些逻辑同样可以分离出来单独写，存的过程解决了渗透入工程内，上传删除包括分级这些逻辑其实本身就很独立。</h4><p>在实现上用了Aspects这个库，主要就是hook方法，用它主要是对一些例外情况处理不错，自己写简单实现其实就只写写方法交换剩下的就不管了。。。</p>\n<p>下面说一下.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">extern NSString * const AOPLoggerMethod;//要统计的日志方法Key</div><div class=\"line\">extern NSString * const AOPLoggerLogInfo;//要统计的日志信息Key</div><div class=\"line\">extern NSString * const AOPLoggerPositionAfter;//方法执行后统计日志</div><div class=\"line\">extern NSString * const AOPLoggerPositionBefore;//方法执行前统计日志</div><div class=\"line\">extern NSString * const AOPLoggerPositionType;//执行日志统计的类型Key</div><div class=\"line\"></div><div class=\"line\">@protocol AOPLoggerGetConfigInfoProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">创建类扩展如果使用此协议必须实现此方法</div><div class=\"line\">此方法返回统计的配置信息，可以从网络取也可以从本地取</div><div class=\"line\">@return 统计配置字典</div><div class=\"line\">*/</div><div class=\"line\">-(NSDictionary*)al_getConfigInfo;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@protocol AOPLoggerBLLProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">创建类扩展如果使用此协议必须实现此方法</div><div class=\"line\">此方法主要来处理切面方法后的log信息处理可以存本地也可以使用其他任意第三方输出</div><div class=\"line\">@param log 配置文件里定义的AOPLoggerLogInfo信息</div><div class=\"line\">@param originAOP AspectInfo的方法信息，第三方库Aspect返回的切面方法的所有信息</div><div class=\"line\">*/</div><div class=\"line\">-(void)al_logger:(id)log originAOP:(id)originAOP;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface AOPLogger : NSObject</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">开始读取日志Plist配置文件</div><div class=\"line\">*/</div><div class=\"line\">+(void)startAOPLoggerWithPlist;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">统计日志的调用方法</div><div class=\"line\">（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）</div><div class=\"line\">@param classString 类名</div><div class=\"line\">@param methodString 方法名</div><div class=\"line\">@param log 相当于AOPLoggerLogInfo信息</div><div class=\"line\">*/</div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString*)classString methodString:(NSString*)methodString log:(id)log;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">统计日志的调用方法</div><div class=\"line\">（如果不想增加开机时间可以采取每个模块创建一个日志统计类适时调用，在该类里提供一个初始化方法，内部调用此即可）</div><div class=\"line\">@param classString 类名</div><div class=\"line\">@param methodString 方法名</div><div class=\"line\">@param log 相当于AOPLoggerLogInfo信息</div><div class=\"line\">@param logPosition 日志统计时位置，可放在方法运行前或运行后（默认运行后执行日志统计）</div><div class=\"line\">*/</div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>","more":"<p>这里提供了两种方式一种直接读取自定义的Plist，一种就是调用类方法，而即使调用类方法，也是单独建一个类，某个模块的日志类负责记录，传入类名方法名统计信息即可，而plist得形式在初期还好，后期统计曾多可就真的太扯了毕竟要在初始化的时候加载遍历执行<br><img src=\"http://upload-images.jianshu.io/upload_images/3994053-46f6bef1c87511f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20170306-012628.png\"></p>\n<h1 id=\"定制扩展\"><a href=\"#定制扩展\" class=\"headerlink\" title=\"定制扩展\"></a>定制扩展</h1><p>由于每个项目想要做的事情或逻辑都会有不同，这里就可以根据我的协议实现对应的方法，来完成自己的业务需求<br>如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &quot;AOPLogger+Custom.h&quot;</div><div class=\"line\">#import &quot;Aspects.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation AOPLogger (Custom)</div><div class=\"line\"></div><div class=\"line\">-(void)al_logger:(id)log originAOP:(id)originAOP&#123;</div><div class=\"line\">if ([log isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">NSLog(@&quot;event:%@&quot;,log);</div><div class=\"line\">&#125;</div><div class=\"line\">if ([log isKindOfClass:[NSDictionary class]]) &#123;</div><div class=\"line\">NSLog(@&quot;eventName:%@\\neventLabel:%@\\neventTime:%@&quot;,log[@&quot;EventName&quot;],log[@&quot;EventLabel&quot;],[log[@&quot;EventTime&quot;] boolValue]?[NSDate date]:@&quot;不用获取&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">if (originAOP&amp;&amp;[originAOP conformsToProtocol:objc_getProtocol(&quot;AspectInfo&quot;)]) &#123;</div><div class=\"line\">id&lt;AspectInfo&gt; aspectInfo=originAOP;</div><div class=\"line\">NSLog(@&quot;originClass:%@\\noriginSel:%@&quot;,NSStringFromClass([aspectInfo.originalInvocation.target class]),NSStringFromSelector(aspectInfo.originalInvocation.selector));</div><div class=\"line\"></div><div class=\"line\">for (NSInteger i=0; i&lt;aspectInfo.arguments.count; i++) &#123;</div><div class=\"line\">NSLog(@&quot;argument:%@&quot;,aspectInfo.arguments[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>这里只是做了简单的NSLog操作，而当某个业务模块下需要不同处理的时候，不妨就直接hook这个方法添加逻辑，用法完全靠个人想像吧，其实用起来经常能处理很多神奇的逻辑，里面的originAOP如果用过Aspects这个库的话可能会很快明白为什么要选这个库不是自己写了，因为它的这块封装可以让我拿到对应方法执行完后返回的值，当然你得指定这个log是在原方法执行完成后执行，同理如果放在执行前执行log我们通过这个对象还可以拿到方法传递的参数。</p>\n<p>再看.m的源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;AOPLogger.h&quot;</div><div class=\"line\">#import &quot;Aspects.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">NSString * const AOPLoggerMethod=@&quot;AOPLoggerMethod&quot;;</div><div class=\"line\">NSString * const AOPLoggerLogInfo=@&quot;AOPLoggerLogInfo&quot;;</div><div class=\"line\">NSString * const AOPLoggerPositionAfter=@&quot;AOPLoggerPositionAfter&quot;;</div><div class=\"line\">NSString * const AOPLoggerPositionBefore=@&quot;AOPLoggerPositionBefore&quot;;</div><div class=\"line\">NSString * const AOPLoggerPositionType=@&quot;AOPLoggerPositionType&quot;;</div><div class=\"line\"></div><div class=\"line\">@implementation AOPLogger</div><div class=\"line\"></div><div class=\"line\">+ (AOPLogger *)sharedAOPLogger &#123;</div><div class=\"line\">static AOPLogger *sharedAOPLogger = nil;</div><div class=\"line\">static dispatch_once_t onceToken;</div><div class=\"line\">dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">sharedAOPLogger = [[self alloc] init];</div><div class=\"line\">&#125;);</div><div class=\"line\">return sharedAOPLogger;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)startAOPLoggerWithPlist&#123;</div><div class=\"line\">NSDictionary *loggerConfigInfo=nil;</div><div class=\"line\">if ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(&quot;AOPLoggerGetConfigInfoProtocol&quot;)]) &#123;</div><div class=\"line\">loggerConfigInfo=[(AOPLogger&lt;AOPLoggerGetConfigInfoProtocol&gt;*)[AOPLogger sharedAOPLogger] al_getConfigInfo];</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">loggerConfigInfo=[NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;AOPLoggerConfig&quot; ofType:@&quot;plist&quot;]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for (NSString *className in loggerConfigInfo) &#123;</div><div class=\"line\">for (NSDictionary *eventInfo in loggerConfigInfo[className]) &#123;</div><div class=\"line\">Class clazz = NSClassFromString(className);</div><div class=\"line\">SEL selector = NSSelectorFromString(eventInfo[AOPLoggerMethod]);</div><div class=\"line\">AspectOptions positionOptions=AspectPositionAfter;</div><div class=\"line\">if ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionAfter]) &#123;</div><div class=\"line\">positionOptions=AspectPositionAfter;</div><div class=\"line\">&#125;</div><div class=\"line\">if ([loggerConfigInfo[AOPLoggerPositionType] isEqualToString:AOPLoggerPositionBefore]) &#123;</div><div class=\"line\">positionOptions=AspectPositionBefore;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[clazz aspect_hookSelector:selector</div><div class=\"line\">withOptions:AspectPositionAfter</div><div class=\"line\">usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class=\"line\">id log=eventInfo[AOPLoggerLogInfo];</div><div class=\"line\"></div><div class=\"line\">if ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(&quot;AOPLoggerBLLProtocol&quot;)]) &#123;</div><div class=\"line\">[(AOPLogger&lt;AOPLoggerBLLProtocol&gt;*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">if ([log isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">NSLog(@&quot;AOPLogger:%@&quot;,log);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; error:NULL];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log&#123;</div><div class=\"line\">[self AOPLoggerWithClassString:classString methodString:methodString log:log logPosition:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)AOPLoggerWithClassString:(NSString *)classString methodString:(NSString *)methodString log:(id)log logPosition:(NSString*)logPosition&#123;</div><div class=\"line\">Class clazz = NSClassFromString(classString);</div><div class=\"line\">SEL selector = NSSelectorFromString(methodString);</div><div class=\"line\">AspectOptions positionOptions=AspectPositionAfter;</div><div class=\"line\">if ([logPosition isEqualToString:AOPLoggerPositionAfter]) &#123;</div><div class=\"line\">positionOptions=AspectPositionAfter;</div><div class=\"line\">&#125;</div><div class=\"line\">if ([logPosition isEqualToString:AOPLoggerPositionBefore]) &#123;</div><div class=\"line\">positionOptions=AspectPositionBefore;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[clazz aspect_hookSelector:selector</div><div class=\"line\">withOptions:positionOptions</div><div class=\"line\">usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class=\"line\">if ([[AOPLogger sharedAOPLogger] conformsToProtocol:objc_getProtocol(&quot;AOPLoggerBLLProtocol&quot;)]) &#123;</div><div class=\"line\">[(AOPLogger&lt;AOPLoggerBLLProtocol&gt;*)[AOPLogger sharedAOPLogger] al_logger:log originAOP:aspectInfo];</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">if ([log isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">NSLog(@&quot;AOPLogger:%@&quot;,log);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; error:NULL];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>核心处理.m直接不到百行，主要逻辑就是 单例初始化， 读取plist并格式化出执行的类 ·方法·log信息，最后就是利用AOP,切面hook对应方法插入我们统计逻辑。</p>\n<p>有了这个库完全可以日志动态话统计，前提你要做好热更新或使用plist形式。</p>\n<p>源码地址：<a href=\"https://github.com/heroims/AOPLogger\" target=\"_blank\" rel=\"external\">https://github.com/heroims/AOPLogger</a></p>"},{"title":"IOS 网络服务层自动化详解","date":"2017-03-01T18:09:05.000Z","_content":"\n# 前言\n之前的文章http://www.jianshu.com/p/7a3a387584c6 最后提到了网络服务层自动化，今天在详细说说。之前封装了ServerAPI，这套框架本身其实相当于定义了一套规范的。\n自动化的概念还是放最后，先讲清楚这框架，到了后面自动化概念自然而然就出来了。\n#ServerAPI 分析与网络服务层构建\n框架本身构成主要有4部分\n### ServerAPI\n主要对后台的API接口做对应描述，相当于网络请求的配置文件Model，定义了请求地址，重试次数，超时时间，返回数据类型，解析数据类型，上传方式等等，，除了常用描述还封装了常用方法算是个标准的胖Model\n常用方法例如，请求地址这里也是拆分成host ，path ，pathParameter，parameter，内部封装了组合逻辑，下面4个属性\nhost：http://xxxx/\npath：module/{xxxmudleID}\npathParameter：xxxmudleID:xxxx\nparameter：key:value\n可以拼成http://xxxx/module/xxxmudleID?key=value 这个url，还有自动为每一次请求生成唯一ID，对请求打Tag方便归类，包括发起请求这也提供了方法，不过实现当然不在这，毕竟他只负责描述\n\n\n### ServerAPIManager\n主要负责管理请求和根据api发起请求，框架内他只是一个管理者逻辑，对发起的请求做归类管理，而发起请求包括缓存逻辑这里通过Category来实现，而具体要实现哪些，由最后面的协议类定义，这样框架本身不去对网络层实现，缓存层实现做干涉，方便更自由的定制化，例如网络层AFN，ASI，还是其他语言都跟框架本身无关，所以这里框架本身只是一个壳，移植性较高，同样的思想拿到其他平台依然适用\n### ServerResult\n主要把返回的数据用通用型实体表示，包括发起的api，发起请求的request对象，返回的源数据，返回的格式化数据，返回的错误，状态等，由于牵扯到数据格式化，所以这里依然是通过Category实现对应方法，方便扩展\n\nps：不支持扩展的语言，继承也可以\n<!-- more -->\n### ServerAPIProtocol\n主要负责定义要在Category里实现的方法，这里我直接放源码，注释还算全，关键内容不多，这就是描述要实现哪些才能让框架跑起来，具体方法放那里具体怎么用每个人有每个人不同的想法\n```Objective-C\n//通过Category对ServerAPI实现对应的协议\n\n@class ServerAPI;\n\ntypedef void  (^sap_requestFailHandle)(ServerResult *result, NSError* errInfo);\ntypedef void  (^sap_requestSuccessHandle)(ServerResult *result);\n\n#pragma mark - 必须实现的协议\n@protocol ServerAPIManagerRequestProtocol <NSObject>\n\n@required\n\n/**\n发起请求逻辑实现 方便用AFN，ASI或自己写\n@param api 请求描述的ServerAPI\n@param completion 请求回调\n@param progressHandle 请求进度\n*/\n-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;\n\n/**\n取消一个请求\n@param api 请求描述的ServerAPI\n*/\n-(void)cancelRequestWithAPI:(ServerAPI*)api;\n\n@optional\n\n/**\n发起请求逻辑实现 方便用AFN，ASI或自己写\n@param api 请求描述的ServerAPI\n@param successHandle 请求成功回调\n@param failHandle 请求失败回调\n@param progressHandle 请求进度\n*/\n-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle progressHandle:(sap_progressHandle)progressHandle;\n\n\n/**\n根据requestID取消一个请求\n@param requestID 请求唯一ID\n*/\n-(void)cancelRequestWithRequestID:(NSString*)requestID;\n\n/**\n根据requestsTag取消某一类表示的请求\n@param requestsTag 请求分类标识\n*/\n-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;\n\n/**\n根据requestID数组取消相关请求\n@param requestList requestID的数组\n*/\n-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;\n\n/**\n根据ServerAPI数组取消相关请求\n@param requestList ServerAPI的数组\n*/\n-(void)cancelRequestWithAPIList:(NSArray*)requestList;\n\n/**\n取消最后一个请求\n*/\n-(void)cancelLastRequest;\n\n/**\n取消第一个请求\n*/\n-(void)cancelFirstRequest;\n\n@end\n\n@protocol ServerAPIResponseProtocol <NSObject>\n\n@required\n\n/**\n请求结束时间   最好设置时放到responseFormatWithData方法内\n@return 请求结束时间\n*/\n-(NSDate *)endDate;\n\n/**\n数据格式化处理\n@param data 数据源\n@param error 错误源\n@param completion 请求回调\n@param cacheData 缓存数据\n*/\n-(void)responseFormatWithData:(id)data error:(NSError*)error completion:(sap_requestCompletion)completion cacheData:(id)cacheData;\n@optional\n\n/**\n数据格式化后的处理 用于对ServerAPI实现Category加入部分业务逻辑\n@param result 格式化数据\n*/\n-(void)responseCustomDoInCategoryWithResult:(ServerResult*)result;\n\n@end\n\n#pragma mark - 可选协议\n@protocol ServerAPIManagerCacheProtocol <NSObject>\n\n@optional\n\n/**\n拉取缓存数据\n@param api 请求描述的ServerAPI\n@param completion 请求回调\n@param error 错误信息\n@return 缓存有无\n*/\n-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion error:(NSError*)error;\n\n/**\n拉取缓存数据\n@param api 请求描述的ServerAPI\n@param successHandle 请求成功回调\n@param failHandle 请求失败回调\n@param error 错误信息\n@return 缓存有无\n*/\n-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api successHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle error:(NSError*)error;\n\n/**\n保存缓存\n@param api 请求描述的ServerAPI\n*/\n-(void)saveDataCacheWithResult:(ServerAPI*)api;\n@end\n\n/**\n与ServerAPIRequstProtocol的协议有重叠主要用于内部封装逻辑\n*/\n@protocol ServerAPIRequstOptionalProtocol <NSObject>\n\n@optional\n-(void)requestDataWithSuccessHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle;\n\n+(ServerAPI*)newRequestDataWithSuccessHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;\n\n@end\n\n/**\n与ServerAPIManagerRequestProtocol的协议有重叠主要用于内部封装逻辑\n*/\n@protocol ServerAPIManagerRequestOptionalProtocol <NSObject>\n\n@optional\n-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;\n\n-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;\n\n-(void)cancelRequestWithAPI:(ServerAPI*)api;\n-(void)cancelRequestWithRequestID:(NSString*)requestID;\n-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;\n-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;\n-(void)cancelRequestWithAPIList:(NSArray*)requestList;\n-(void)cancelLastRequest;\n-(void)cancelFirstRequest;\n\n@end\n```\n源码地址：https://github.com/heroims/ServerAPI/\n#ServerAPI使用\n下面说说怎么用，按这种模式填充完自己定制的方法实现后，既可以当做离散型API用也会可以当做集约型API用，还可以直接用URL\n```Objective-C\n//离散型API使用  一个请求是一个API类，用NSClassFromString主要为了省头文件引用懒得加头文件。。。           \n[NSClassFromString(@\"DemoAPI\") newRequestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n} requestParameters:nil requestTag:NSStringFromClass([self class])];\n\nServerAPI *discreteApi=[[NSClassFromString(@\"DemoAPI\") alloc] init];\ndiscreteApi.requestParameters=nil;\ndiscreteApi.requestTag=NSStringFromClass([self class]);\n[discreteApi requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n}];\n\n//集约型API使用  可以直接类扩展加静态方法设置，可以自行类扩展个更简洁通用的方法这里只距离\nServerAPI *intensiveAPI=[[ServerAPI alloc] init];\nintensiveAPI.requestHost=@\"http://xxx.xxx.xxx\";\nintensiveAPI.requestPath=@\"xxx\";\nintensiveAPI.requestParameters=nil;\nintensiveAPI.requestTag=NSStringFromClass([self class]);\nintensiveAPI.accessType=APIAccessType_Get;\nintensiveAPI.resultFormat=APIResultFormat_JSON;\nintensiveAPI.timeOut=30;\nintensiveAPI.retryTimes=2;\n[intensiveAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n}];\n\n//直接请求Url\nServerAPI *urlAPI=[[ServerAPI alloc] init];\nurlAPI.requestURL=@\"http://xxx.xxx.xxx\";\nurlAPI.requestTag=NSStringFromClass([self class]);\n[urlAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n}];\n\n```\n# ServerAPI自动化产出（离散型API好处）\n当采用了离散型API时，调用的时候通常只需要初始化对应的API，传入后台要的参数，至此数据返回，一个请求完成。\n通过继承ServerAPI，return 描述的固定值一个对应的API类就创建完成，然后回到之前的文章，如果服务端写的代码工整或有地方统一定义直接可以自动导出一套API的所有描述文件，也就是各各XXXAPI，哪怕代码不工整，API文档总该有吧，有点格式就可以读出来自动生成API，如果还没有，，，，好吧，那就帮他们规范化所以有了下面我用Swift写的工具 。\n#### ServerAPICreator\nhttps://github.com/heroims/ServerAPICreator\n功能很简单，就是对API接口的描述，填完自动生成wiki.md和一堆XXXAPI.h,XXXAPI.m文件。\n这种东西就是定制化比较高的东西了，所以代码也就看看吧，拿来直接用是不可能的，怎样都要改改，但思路相信看到这的人基本都有了\n\n![687474703a2f2f6865726f696d732e6769746875622e696f2f53657276657241504943726561746f722f32414530344336422d364233422d343738332d393537322d4143423746333632314641432e706e67.png](http://upload-images.jianshu.io/upload_images/3994053-254e821d28eb7c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 联想\n按照这种设计架构的方式很多层面的东西都会渐渐的用描述解决，开发一套东西需要的是脚本描述。核心引擎好了，想想人工智能是不是不断积累数据，产出脚本描述然后不断的自动写代码给自己打patch（随便一说扯扯淡）。。。。\n","source":"_posts/IOS 网络服务层自动化详解.md","raw":"---\ntitle: IOS 网络服务层自动化详解\ndate: 2017-03-02 02:09:05\ntags:\n---\n\n# 前言\n之前的文章http://www.jianshu.com/p/7a3a387584c6 最后提到了网络服务层自动化，今天在详细说说。之前封装了ServerAPI，这套框架本身其实相当于定义了一套规范的。\n自动化的概念还是放最后，先讲清楚这框架，到了后面自动化概念自然而然就出来了。\n#ServerAPI 分析与网络服务层构建\n框架本身构成主要有4部分\n### ServerAPI\n主要对后台的API接口做对应描述，相当于网络请求的配置文件Model，定义了请求地址，重试次数，超时时间，返回数据类型，解析数据类型，上传方式等等，，除了常用描述还封装了常用方法算是个标准的胖Model\n常用方法例如，请求地址这里也是拆分成host ，path ，pathParameter，parameter，内部封装了组合逻辑，下面4个属性\nhost：http://xxxx/\npath：module/{xxxmudleID}\npathParameter：xxxmudleID:xxxx\nparameter：key:value\n可以拼成http://xxxx/module/xxxmudleID?key=value 这个url，还有自动为每一次请求生成唯一ID，对请求打Tag方便归类，包括发起请求这也提供了方法，不过实现当然不在这，毕竟他只负责描述\n\n\n### ServerAPIManager\n主要负责管理请求和根据api发起请求，框架内他只是一个管理者逻辑，对发起的请求做归类管理，而发起请求包括缓存逻辑这里通过Category来实现，而具体要实现哪些，由最后面的协议类定义，这样框架本身不去对网络层实现，缓存层实现做干涉，方便更自由的定制化，例如网络层AFN，ASI，还是其他语言都跟框架本身无关，所以这里框架本身只是一个壳，移植性较高，同样的思想拿到其他平台依然适用\n### ServerResult\n主要把返回的数据用通用型实体表示，包括发起的api，发起请求的request对象，返回的源数据，返回的格式化数据，返回的错误，状态等，由于牵扯到数据格式化，所以这里依然是通过Category实现对应方法，方便扩展\n\nps：不支持扩展的语言，继承也可以\n<!-- more -->\n### ServerAPIProtocol\n主要负责定义要在Category里实现的方法，这里我直接放源码，注释还算全，关键内容不多，这就是描述要实现哪些才能让框架跑起来，具体方法放那里具体怎么用每个人有每个人不同的想法\n```Objective-C\n//通过Category对ServerAPI实现对应的协议\n\n@class ServerAPI;\n\ntypedef void  (^sap_requestFailHandle)(ServerResult *result, NSError* errInfo);\ntypedef void  (^sap_requestSuccessHandle)(ServerResult *result);\n\n#pragma mark - 必须实现的协议\n@protocol ServerAPIManagerRequestProtocol <NSObject>\n\n@required\n\n/**\n发起请求逻辑实现 方便用AFN，ASI或自己写\n@param api 请求描述的ServerAPI\n@param completion 请求回调\n@param progressHandle 请求进度\n*/\n-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;\n\n/**\n取消一个请求\n@param api 请求描述的ServerAPI\n*/\n-(void)cancelRequestWithAPI:(ServerAPI*)api;\n\n@optional\n\n/**\n发起请求逻辑实现 方便用AFN，ASI或自己写\n@param api 请求描述的ServerAPI\n@param successHandle 请求成功回调\n@param failHandle 请求失败回调\n@param progressHandle 请求进度\n*/\n-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle progressHandle:(sap_progressHandle)progressHandle;\n\n\n/**\n根据requestID取消一个请求\n@param requestID 请求唯一ID\n*/\n-(void)cancelRequestWithRequestID:(NSString*)requestID;\n\n/**\n根据requestsTag取消某一类表示的请求\n@param requestsTag 请求分类标识\n*/\n-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;\n\n/**\n根据requestID数组取消相关请求\n@param requestList requestID的数组\n*/\n-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;\n\n/**\n根据ServerAPI数组取消相关请求\n@param requestList ServerAPI的数组\n*/\n-(void)cancelRequestWithAPIList:(NSArray*)requestList;\n\n/**\n取消最后一个请求\n*/\n-(void)cancelLastRequest;\n\n/**\n取消第一个请求\n*/\n-(void)cancelFirstRequest;\n\n@end\n\n@protocol ServerAPIResponseProtocol <NSObject>\n\n@required\n\n/**\n请求结束时间   最好设置时放到responseFormatWithData方法内\n@return 请求结束时间\n*/\n-(NSDate *)endDate;\n\n/**\n数据格式化处理\n@param data 数据源\n@param error 错误源\n@param completion 请求回调\n@param cacheData 缓存数据\n*/\n-(void)responseFormatWithData:(id)data error:(NSError*)error completion:(sap_requestCompletion)completion cacheData:(id)cacheData;\n@optional\n\n/**\n数据格式化后的处理 用于对ServerAPI实现Category加入部分业务逻辑\n@param result 格式化数据\n*/\n-(void)responseCustomDoInCategoryWithResult:(ServerResult*)result;\n\n@end\n\n#pragma mark - 可选协议\n@protocol ServerAPIManagerCacheProtocol <NSObject>\n\n@optional\n\n/**\n拉取缓存数据\n@param api 请求描述的ServerAPI\n@param completion 请求回调\n@param error 错误信息\n@return 缓存有无\n*/\n-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion error:(NSError*)error;\n\n/**\n拉取缓存数据\n@param api 请求描述的ServerAPI\n@param successHandle 请求成功回调\n@param failHandle 请求失败回调\n@param error 错误信息\n@return 缓存有无\n*/\n-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api successHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle error:(NSError*)error;\n\n/**\n保存缓存\n@param api 请求描述的ServerAPI\n*/\n-(void)saveDataCacheWithResult:(ServerAPI*)api;\n@end\n\n/**\n与ServerAPIRequstProtocol的协议有重叠主要用于内部封装逻辑\n*/\n@protocol ServerAPIRequstOptionalProtocol <NSObject>\n\n@optional\n-(void)requestDataWithSuccessHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle;\n\n+(ServerAPI*)newRequestDataWithSuccessHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;\n\n@end\n\n/**\n与ServerAPIManagerRequestProtocol的协议有重叠主要用于内部封装逻辑\n*/\n@protocol ServerAPIManagerRequestOptionalProtocol <NSObject>\n\n@optional\n-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;\n\n-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;\n\n-(void)cancelRequestWithAPI:(ServerAPI*)api;\n-(void)cancelRequestWithRequestID:(NSString*)requestID;\n-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;\n-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;\n-(void)cancelRequestWithAPIList:(NSArray*)requestList;\n-(void)cancelLastRequest;\n-(void)cancelFirstRequest;\n\n@end\n```\n源码地址：https://github.com/heroims/ServerAPI/\n#ServerAPI使用\n下面说说怎么用，按这种模式填充完自己定制的方法实现后，既可以当做离散型API用也会可以当做集约型API用，还可以直接用URL\n```Objective-C\n//离散型API使用  一个请求是一个API类，用NSClassFromString主要为了省头文件引用懒得加头文件。。。           \n[NSClassFromString(@\"DemoAPI\") newRequestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n} requestParameters:nil requestTag:NSStringFromClass([self class])];\n\nServerAPI *discreteApi=[[NSClassFromString(@\"DemoAPI\") alloc] init];\ndiscreteApi.requestParameters=nil;\ndiscreteApi.requestTag=NSStringFromClass([self class]);\n[discreteApi requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n}];\n\n//集约型API使用  可以直接类扩展加静态方法设置，可以自行类扩展个更简洁通用的方法这里只距离\nServerAPI *intensiveAPI=[[ServerAPI alloc] init];\nintensiveAPI.requestHost=@\"http://xxx.xxx.xxx\";\nintensiveAPI.requestPath=@\"xxx\";\nintensiveAPI.requestParameters=nil;\nintensiveAPI.requestTag=NSStringFromClass([self class]);\nintensiveAPI.accessType=APIAccessType_Get;\nintensiveAPI.resultFormat=APIResultFormat_JSON;\nintensiveAPI.timeOut=30;\nintensiveAPI.retryTimes=2;\n[intensiveAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n}];\n\n//直接请求Url\nServerAPI *urlAPI=[[ServerAPI alloc] init];\nurlAPI.requestURL=@\"http://xxx.xxx.xxx\";\nurlAPI.requestTag=NSStringFromClass([self class]);\n[urlAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) {\n\n}];\n\n```\n# ServerAPI自动化产出（离散型API好处）\n当采用了离散型API时，调用的时候通常只需要初始化对应的API，传入后台要的参数，至此数据返回，一个请求完成。\n通过继承ServerAPI，return 描述的固定值一个对应的API类就创建完成，然后回到之前的文章，如果服务端写的代码工整或有地方统一定义直接可以自动导出一套API的所有描述文件，也就是各各XXXAPI，哪怕代码不工整，API文档总该有吧，有点格式就可以读出来自动生成API，如果还没有，，，，好吧，那就帮他们规范化所以有了下面我用Swift写的工具 。\n#### ServerAPICreator\nhttps://github.com/heroims/ServerAPICreator\n功能很简单，就是对API接口的描述，填完自动生成wiki.md和一堆XXXAPI.h,XXXAPI.m文件。\n这种东西就是定制化比较高的东西了，所以代码也就看看吧，拿来直接用是不可能的，怎样都要改改，但思路相信看到这的人基本都有了\n\n![687474703a2f2f6865726f696d732e6769746875622e696f2f53657276657241504943726561746f722f32414530344336422d364233422d343738332d393537322d4143423746333632314641432e706e67.png](http://upload-images.jianshu.io/upload_images/3994053-254e821d28eb7c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 联想\n按照这种设计架构的方式很多层面的东西都会渐渐的用描述解决，开发一套东西需要的是脚本描述。核心引擎好了，想想人工智能是不是不断积累数据，产出脚本描述然后不断的自动写代码给自己打patch（随便一说扯扯淡）。。。。\n","slug":"IOS 网络服务层自动化详解","published":1,"updated":"2017-08-13T20:29:55.000Z","_id":"cj6b62e0y0002u16a51niefxb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前的文章<a href=\"http://www.jianshu.com/p/7a3a387584c6\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7a3a387584c6</a> 最后提到了网络服务层自动化，今天在详细说说。之前封装了ServerAPI，这套框架本身其实相当于定义了一套规范的。<br>自动化的概念还是放最后，先讲清楚这框架，到了后面自动化概念自然而然就出来了。</p>\n<p>#ServerAPI 分析与网络服务层构建<br>框架本身构成主要有4部分</p>\n<h3 id=\"ServerAPI\"><a href=\"#ServerAPI\" class=\"headerlink\" title=\"ServerAPI\"></a>ServerAPI</h3><p>主要对后台的API接口做对应描述，相当于网络请求的配置文件Model，定义了请求地址，重试次数，超时时间，返回数据类型，解析数据类型，上传方式等等，，除了常用描述还封装了常用方法算是个标准的胖Model<br>常用方法例如，请求地址这里也是拆分成host ，path ，pathParameter，parameter，内部封装了组合逻辑，下面4个属性<br>host：<a href=\"http://xxxx/\" target=\"_blank\" rel=\"external\">http://xxxx/</a><br>path：module/{xxxmudleID}<br>pathParameter：xxxmudleID:xxxx<br>parameter：key:value<br>可以拼成<a href=\"http://xxxx/module/xxxmudleID?key=value\" target=\"_blank\" rel=\"external\">http://xxxx/module/xxxmudleID?key=value</a> 这个url，还有自动为每一次请求生成唯一ID，对请求打Tag方便归类，包括发起请求这也提供了方法，不过实现当然不在这，毕竟他只负责描述</p>\n<h3 id=\"ServerAPIManager\"><a href=\"#ServerAPIManager\" class=\"headerlink\" title=\"ServerAPIManager\"></a>ServerAPIManager</h3><p>主要负责管理请求和根据api发起请求，框架内他只是一个管理者逻辑，对发起的请求做归类管理，而发起请求包括缓存逻辑这里通过Category来实现，而具体要实现哪些，由最后面的协议类定义，这样框架本身不去对网络层实现，缓存层实现做干涉，方便更自由的定制化，例如网络层AFN，ASI，还是其他语言都跟框架本身无关，所以这里框架本身只是一个壳，移植性较高，同样的思想拿到其他平台依然适用</p>\n<h3 id=\"ServerResult\"><a href=\"#ServerResult\" class=\"headerlink\" title=\"ServerResult\"></a>ServerResult</h3><p>主要把返回的数据用通用型实体表示，包括发起的api，发起请求的request对象，返回的源数据，返回的格式化数据，返回的错误，状态等，由于牵扯到数据格式化，所以这里依然是通过Category实现对应方法，方便扩展</p>\n<p>ps：不支持扩展的语言，继承也可以<br><a id=\"more\"></a></p>\n<h3 id=\"ServerAPIProtocol\"><a href=\"#ServerAPIProtocol\" class=\"headerlink\" title=\"ServerAPIProtocol\"></a>ServerAPIProtocol</h3><p>主要负责定义要在Category里实现的方法，这里我直接放源码，注释还算全，关键内容不多，这就是描述要实现哪些才能让框架跑起来，具体方法放那里具体怎么用每个人有每个人不同的想法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过Category对ServerAPI实现对应的协议</div><div class=\"line\"></div><div class=\"line\">@class ServerAPI;</div><div class=\"line\"></div><div class=\"line\">typedef void  (^sap_requestFailHandle)(ServerResult *result, NSError* errInfo);</div><div class=\"line\">typedef void  (^sap_requestSuccessHandle)(ServerResult *result);</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 必须实现的协议</div><div class=\"line\">@protocol ServerAPIManagerRequestProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">发起请求逻辑实现 方便用AFN，ASI或自己写</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param completion 请求回调</div><div class=\"line\">@param progressHandle 请求进度</div><div class=\"line\">*/</div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">取消一个请求</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithAPI:(ServerAPI*)api;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">发起请求逻辑实现 方便用AFN，ASI或自己写</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param successHandle 请求成功回调</div><div class=\"line\">@param failHandle 请求失败回调</div><div class=\"line\">@param progressHandle 请求进度</div><div class=\"line\">*/</div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle progressHandle:(sap_progressHandle)progressHandle;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据requestID取消一个请求</div><div class=\"line\">@param requestID 请求唯一ID</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithRequestID:(NSString*)requestID;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据requestsTag取消某一类表示的请求</div><div class=\"line\">@param requestsTag 请求分类标识</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据requestID数组取消相关请求</div><div class=\"line\">@param requestList requestID的数组</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据ServerAPI数组取消相关请求</div><div class=\"line\">@param requestList ServerAPI的数组</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithAPIList:(NSArray*)requestList;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">取消最后一个请求</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelLastRequest;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">取消第一个请求</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelFirstRequest;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@protocol ServerAPIResponseProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">请求结束时间   最好设置时放到responseFormatWithData方法内</div><div class=\"line\">@return 请求结束时间</div><div class=\"line\">*/</div><div class=\"line\">-(NSDate *)endDate;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">数据格式化处理</div><div class=\"line\">@param data 数据源</div><div class=\"line\">@param error 错误源</div><div class=\"line\">@param completion 请求回调</div><div class=\"line\">@param cacheData 缓存数据</div><div class=\"line\">*/</div><div class=\"line\">-(void)responseFormatWithData:(id)data error:(NSError*)error completion:(sap_requestCompletion)completion cacheData:(id)cacheData;</div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">数据格式化后的处理 用于对ServerAPI实现Category加入部分业务逻辑</div><div class=\"line\">@param result 格式化数据</div><div class=\"line\">*/</div><div class=\"line\">-(void)responseCustomDoInCategoryWithResult:(ServerResult*)result;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 可选协议</div><div class=\"line\">@protocol ServerAPIManagerCacheProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">拉取缓存数据</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param completion 请求回调</div><div class=\"line\">@param error 错误信息</div><div class=\"line\">@return 缓存有无</div><div class=\"line\">*/</div><div class=\"line\">-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion error:(NSError*)error;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">拉取缓存数据</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param successHandle 请求成功回调</div><div class=\"line\">@param failHandle 请求失败回调</div><div class=\"line\">@param error 错误信息</div><div class=\"line\">@return 缓存有无</div><div class=\"line\">*/</div><div class=\"line\">-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api successHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle error:(NSError*)error;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">保存缓存</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">*/</div><div class=\"line\">-(void)saveDataCacheWithResult:(ServerAPI*)api;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">与ServerAPIRequstProtocol的协议有重叠主要用于内部封装逻辑</div><div class=\"line\">*/</div><div class=\"line\">@protocol ServerAPIRequstOptionalProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(void)requestDataWithSuccessHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle;</div><div class=\"line\"></div><div class=\"line\">+(ServerAPI*)newRequestDataWithSuccessHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">与ServerAPIManagerRequestProtocol的协议有重叠主要用于内部封装逻辑</div><div class=\"line\">*/</div><div class=\"line\">@protocol ServerAPIManagerRequestOptionalProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;</div><div class=\"line\"></div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelRequestWithAPI:(ServerAPI*)api;</div><div class=\"line\">-(void)cancelRequestWithRequestID:(NSString*)requestID;</div><div class=\"line\">-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;</div><div class=\"line\">-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;</div><div class=\"line\">-(void)cancelRequestWithAPIList:(NSArray*)requestList;</div><div class=\"line\">-(void)cancelLastRequest;</div><div class=\"line\">-(void)cancelFirstRequest;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>源码地址：<a href=\"https://github.com/heroims/ServerAPI/\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPI/</a></p>\n<p>#ServerAPI使用<br>下面说说怎么用，按这种模式填充完自己定制的方法实现后，既可以当做离散型API用也会可以当做集约型API用，还可以直接用URL<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">//离散型API使用  一个请求是一个API类，用NSClassFromString主要为了省头文件引用懒得加头文件。。。           </div><div class=\"line\">[NSClassFromString(@&quot;DemoAPI&quot;) newRequestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125; requestParameters:nil requestTag:NSStringFromClass([self class])];</div><div class=\"line\"></div><div class=\"line\">ServerAPI *discreteApi=[[NSClassFromString(@&quot;DemoAPI&quot;) alloc] init];</div><div class=\"line\">discreteApi.requestParameters=nil;</div><div class=\"line\">discreteApi.requestTag=NSStringFromClass([self class]);</div><div class=\"line\">[discreteApi requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//集约型API使用  可以直接类扩展加静态方法设置，可以自行类扩展个更简洁通用的方法这里只距离</div><div class=\"line\">ServerAPI *intensiveAPI=[[ServerAPI alloc] init];</div><div class=\"line\">intensiveAPI.requestHost=@&quot;http://xxx.xxx.xxx&quot;;</div><div class=\"line\">intensiveAPI.requestPath=@&quot;xxx&quot;;</div><div class=\"line\">intensiveAPI.requestParameters=nil;</div><div class=\"line\">intensiveAPI.requestTag=NSStringFromClass([self class]);</div><div class=\"line\">intensiveAPI.accessType=APIAccessType_Get;</div><div class=\"line\">intensiveAPI.resultFormat=APIResultFormat_JSON;</div><div class=\"line\">intensiveAPI.timeOut=30;</div><div class=\"line\">intensiveAPI.retryTimes=2;</div><div class=\"line\">[intensiveAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//直接请求Url</div><div class=\"line\">ServerAPI *urlAPI=[[ServerAPI alloc] init];</div><div class=\"line\">urlAPI.requestURL=@&quot;http://xxx.xxx.xxx&quot;;</div><div class=\"line\">urlAPI.requestTag=NSStringFromClass([self class]);</div><div class=\"line\">[urlAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h1 id=\"ServerAPI自动化产出（离散型API好处）\"><a href=\"#ServerAPI自动化产出（离散型API好处）\" class=\"headerlink\" title=\"ServerAPI自动化产出（离散型API好处）\"></a>ServerAPI自动化产出（离散型API好处）</h1><p>当采用了离散型API时，调用的时候通常只需要初始化对应的API，传入后台要的参数，至此数据返回，一个请求完成。<br>通过继承ServerAPI，return 描述的固定值一个对应的API类就创建完成，然后回到之前的文章，如果服务端写的代码工整或有地方统一定义直接可以自动导出一套API的所有描述文件，也就是各各XXXAPI，哪怕代码不工整，API文档总该有吧，有点格式就可以读出来自动生成API，如果还没有，，，，好吧，那就帮他们规范化所以有了下面我用Swift写的工具 。</p>\n<h4 id=\"ServerAPICreator\"><a href=\"#ServerAPICreator\" class=\"headerlink\" title=\"ServerAPICreator\"></a>ServerAPICreator</h4><p><a href=\"https://github.com/heroims/ServerAPICreator\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPICreator</a><br>功能很简单，就是对API接口的描述，填完自动生成wiki.md和一堆XXXAPI.h,XXXAPI.m文件。<br>这种东西就是定制化比较高的东西了，所以代码也就看看吧，拿来直接用是不可能的，怎样都要改改，但思路相信看到这的人基本都有了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3994053-254e821d28eb7c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"687474703a2f2f6865726f696d732e6769746875622e696f2f53657276657241504943726561746f722f32414530344336422d364233422d343738332d393537322d4143423746333632314641432e706e67.png\"></p>\n<h3 id=\"联想\"><a href=\"#联想\" class=\"headerlink\" title=\"联想\"></a>联想</h3><p>按照这种设计架构的方式很多层面的东西都会渐渐的用描述解决，开发一套东西需要的是脚本描述。核心引擎好了，想想人工智能是不是不断积累数据，产出脚本描述然后不断的自动写代码给自己打patch（随便一说扯扯淡）。。。。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前的文章<a href=\"http://www.jianshu.com/p/7a3a387584c6\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7a3a387584c6</a> 最后提到了网络服务层自动化，今天在详细说说。之前封装了ServerAPI，这套框架本身其实相当于定义了一套规范的。<br>自动化的概念还是放最后，先讲清楚这框架，到了后面自动化概念自然而然就出来了。</p>\n<p>#ServerAPI 分析与网络服务层构建<br>框架本身构成主要有4部分</p>\n<h3 id=\"ServerAPI\"><a href=\"#ServerAPI\" class=\"headerlink\" title=\"ServerAPI\"></a>ServerAPI</h3><p>主要对后台的API接口做对应描述，相当于网络请求的配置文件Model，定义了请求地址，重试次数，超时时间，返回数据类型，解析数据类型，上传方式等等，，除了常用描述还封装了常用方法算是个标准的胖Model<br>常用方法例如，请求地址这里也是拆分成host ，path ，pathParameter，parameter，内部封装了组合逻辑，下面4个属性<br>host：<a href=\"http://xxxx/\" target=\"_blank\" rel=\"external\">http://xxxx/</a><br>path：module/{xxxmudleID}<br>pathParameter：xxxmudleID:xxxx<br>parameter：key:value<br>可以拼成<a href=\"http://xxxx/module/xxxmudleID?key=value\" target=\"_blank\" rel=\"external\">http://xxxx/module/xxxmudleID?key=value</a> 这个url，还有自动为每一次请求生成唯一ID，对请求打Tag方便归类，包括发起请求这也提供了方法，不过实现当然不在这，毕竟他只负责描述</p>\n<h3 id=\"ServerAPIManager\"><a href=\"#ServerAPIManager\" class=\"headerlink\" title=\"ServerAPIManager\"></a>ServerAPIManager</h3><p>主要负责管理请求和根据api发起请求，框架内他只是一个管理者逻辑，对发起的请求做归类管理，而发起请求包括缓存逻辑这里通过Category来实现，而具体要实现哪些，由最后面的协议类定义，这样框架本身不去对网络层实现，缓存层实现做干涉，方便更自由的定制化，例如网络层AFN，ASI，还是其他语言都跟框架本身无关，所以这里框架本身只是一个壳，移植性较高，同样的思想拿到其他平台依然适用</p>\n<h3 id=\"ServerResult\"><a href=\"#ServerResult\" class=\"headerlink\" title=\"ServerResult\"></a>ServerResult</h3><p>主要把返回的数据用通用型实体表示，包括发起的api，发起请求的request对象，返回的源数据，返回的格式化数据，返回的错误，状态等，由于牵扯到数据格式化，所以这里依然是通过Category实现对应方法，方便扩展</p>\n<p>ps：不支持扩展的语言，继承也可以<br>","more":"</p>\n<h3 id=\"ServerAPIProtocol\"><a href=\"#ServerAPIProtocol\" class=\"headerlink\" title=\"ServerAPIProtocol\"></a>ServerAPIProtocol</h3><p>主要负责定义要在Category里实现的方法，这里我直接放源码，注释还算全，关键内容不多，这就是描述要实现哪些才能让框架跑起来，具体方法放那里具体怎么用每个人有每个人不同的想法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过Category对ServerAPI实现对应的协议</div><div class=\"line\"></div><div class=\"line\">@class ServerAPI;</div><div class=\"line\"></div><div class=\"line\">typedef void  (^sap_requestFailHandle)(ServerResult *result, NSError* errInfo);</div><div class=\"line\">typedef void  (^sap_requestSuccessHandle)(ServerResult *result);</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 必须实现的协议</div><div class=\"line\">@protocol ServerAPIManagerRequestProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">发起请求逻辑实现 方便用AFN，ASI或自己写</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param completion 请求回调</div><div class=\"line\">@param progressHandle 请求进度</div><div class=\"line\">*/</div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">取消一个请求</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithAPI:(ServerAPI*)api;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">发起请求逻辑实现 方便用AFN，ASI或自己写</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param successHandle 请求成功回调</div><div class=\"line\">@param failHandle 请求失败回调</div><div class=\"line\">@param progressHandle 请求进度</div><div class=\"line\">*/</div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle progressHandle:(sap_progressHandle)progressHandle;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据requestID取消一个请求</div><div class=\"line\">@param requestID 请求唯一ID</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithRequestID:(NSString*)requestID;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据requestsTag取消某一类表示的请求</div><div class=\"line\">@param requestsTag 请求分类标识</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据requestID数组取消相关请求</div><div class=\"line\">@param requestList requestID的数组</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">根据ServerAPI数组取消相关请求</div><div class=\"line\">@param requestList ServerAPI的数组</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelRequestWithAPIList:(NSArray*)requestList;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">取消最后一个请求</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelLastRequest;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">取消第一个请求</div><div class=\"line\">*/</div><div class=\"line\">-(void)cancelFirstRequest;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@protocol ServerAPIResponseProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">请求结束时间   最好设置时放到responseFormatWithData方法内</div><div class=\"line\">@return 请求结束时间</div><div class=\"line\">*/</div><div class=\"line\">-(NSDate *)endDate;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">数据格式化处理</div><div class=\"line\">@param data 数据源</div><div class=\"line\">@param error 错误源</div><div class=\"line\">@param completion 请求回调</div><div class=\"line\">@param cacheData 缓存数据</div><div class=\"line\">*/</div><div class=\"line\">-(void)responseFormatWithData:(id)data error:(NSError*)error completion:(sap_requestCompletion)completion cacheData:(id)cacheData;</div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">数据格式化后的处理 用于对ServerAPI实现Category加入部分业务逻辑</div><div class=\"line\">@param result 格式化数据</div><div class=\"line\">*/</div><div class=\"line\">-(void)responseCustomDoInCategoryWithResult:(ServerResult*)result;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 可选协议</div><div class=\"line\">@protocol ServerAPIManagerCacheProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">拉取缓存数据</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param completion 请求回调</div><div class=\"line\">@param error 错误信息</div><div class=\"line\">@return 缓存有无</div><div class=\"line\">*/</div><div class=\"line\">-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion error:(NSError*)error;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">拉取缓存数据</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">@param successHandle 请求成功回调</div><div class=\"line\">@param failHandle 请求失败回调</div><div class=\"line\">@param error 错误信息</div><div class=\"line\">@return 缓存有无</div><div class=\"line\">*/</div><div class=\"line\">-(BOOL)fetchDataCacheWithAPI:(ServerAPI*)api successHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle error:(NSError*)error;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">保存缓存</div><div class=\"line\">@param api 请求描述的ServerAPI</div><div class=\"line\">*/</div><div class=\"line\">-(void)saveDataCacheWithResult:(ServerAPI*)api;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">与ServerAPIRequstProtocol的协议有重叠主要用于内部封装逻辑</div><div class=\"line\">*/</div><div class=\"line\">@protocol ServerAPIRequstOptionalProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(void)requestDataWithSuccessHandle:(sap_requestCompletion)successHandle failHandle:(sap_requestFailHandle)failHandle;</div><div class=\"line\"></div><div class=\"line\">+(ServerAPI*)newRequestDataWithSuccessHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">与ServerAPIManagerRequestProtocol的协议有重叠主要用于内部封装逻辑</div><div class=\"line\">*/</div><div class=\"line\">@protocol ServerAPIManagerRequestOptionalProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api completion:(sap_requestCompletion)completion progressHandle:(sap_progressHandle)progressHandle;</div><div class=\"line\"></div><div class=\"line\">-(void)requestDataWithAPI:(ServerAPI*)api successHandle:(sap_requestSuccessHandle)successHandle failHandle:(sap_requestFailHandle)failHandle;</div><div class=\"line\"></div><div class=\"line\">-(void)cancelRequestWithAPI:(ServerAPI*)api;</div><div class=\"line\">-(void)cancelRequestWithRequestID:(NSString*)requestID;</div><div class=\"line\">-(void)cancelRequestWithRequestsTag:(NSString*)requestsTag;</div><div class=\"line\">-(void)cancelRequestWithRequestIDList:(NSArray*)requestList;</div><div class=\"line\">-(void)cancelRequestWithAPIList:(NSArray*)requestList;</div><div class=\"line\">-(void)cancelLastRequest;</div><div class=\"line\">-(void)cancelFirstRequest;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>源码地址：<a href=\"https://github.com/heroims/ServerAPI/\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPI/</a></p>\n<p>#ServerAPI使用<br>下面说说怎么用，按这种模式填充完自己定制的方法实现后，既可以当做离散型API用也会可以当做集约型API用，还可以直接用URL<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">//离散型API使用  一个请求是一个API类，用NSClassFromString主要为了省头文件引用懒得加头文件。。。           </div><div class=\"line\">[NSClassFromString(@&quot;DemoAPI&quot;) newRequestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125; requestParameters:nil requestTag:NSStringFromClass([self class])];</div><div class=\"line\"></div><div class=\"line\">ServerAPI *discreteApi=[[NSClassFromString(@&quot;DemoAPI&quot;) alloc] init];</div><div class=\"line\">discreteApi.requestParameters=nil;</div><div class=\"line\">discreteApi.requestTag=NSStringFromClass([self class]);</div><div class=\"line\">[discreteApi requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//集约型API使用  可以直接类扩展加静态方法设置，可以自行类扩展个更简洁通用的方法这里只距离</div><div class=\"line\">ServerAPI *intensiveAPI=[[ServerAPI alloc] init];</div><div class=\"line\">intensiveAPI.requestHost=@&quot;http://xxx.xxx.xxx&quot;;</div><div class=\"line\">intensiveAPI.requestPath=@&quot;xxx&quot;;</div><div class=\"line\">intensiveAPI.requestParameters=nil;</div><div class=\"line\">intensiveAPI.requestTag=NSStringFromClass([self class]);</div><div class=\"line\">intensiveAPI.accessType=APIAccessType_Get;</div><div class=\"line\">intensiveAPI.resultFormat=APIResultFormat_JSON;</div><div class=\"line\">intensiveAPI.timeOut=30;</div><div class=\"line\">intensiveAPI.retryTimes=2;</div><div class=\"line\">[intensiveAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//直接请求Url</div><div class=\"line\">ServerAPI *urlAPI=[[ServerAPI alloc] init];</div><div class=\"line\">urlAPI.requestURL=@&quot;http://xxx.xxx.xxx&quot;;</div><div class=\"line\">urlAPI.requestTag=NSStringFromClass([self class]);</div><div class=\"line\">[urlAPI requestDataWithCompletion:^(ServerResult *result, NSError *errInfo) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h1 id=\"ServerAPI自动化产出（离散型API好处）\"><a href=\"#ServerAPI自动化产出（离散型API好处）\" class=\"headerlink\" title=\"ServerAPI自动化产出（离散型API好处）\"></a>ServerAPI自动化产出（离散型API好处）</h1><p>当采用了离散型API时，调用的时候通常只需要初始化对应的API，传入后台要的参数，至此数据返回，一个请求完成。<br>通过继承ServerAPI，return 描述的固定值一个对应的API类就创建完成，然后回到之前的文章，如果服务端写的代码工整或有地方统一定义直接可以自动导出一套API的所有描述文件，也就是各各XXXAPI，哪怕代码不工整，API文档总该有吧，有点格式就可以读出来自动生成API，如果还没有，，，，好吧，那就帮他们规范化所以有了下面我用Swift写的工具 。</p>\n<h4 id=\"ServerAPICreator\"><a href=\"#ServerAPICreator\" class=\"headerlink\" title=\"ServerAPICreator\"></a>ServerAPICreator</h4><p><a href=\"https://github.com/heroims/ServerAPICreator\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPICreator</a><br>功能很简单，就是对API接口的描述，填完自动生成wiki.md和一堆XXXAPI.h,XXXAPI.m文件。<br>这种东西就是定制化比较高的东西了，所以代码也就看看吧，拿来直接用是不可能的，怎样都要改改，但思路相信看到这的人基本都有了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3994053-254e821d28eb7c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"687474703a2f2f6865726f696d732e6769746875622e696f2f53657276657241504943726561746f722f32414530344336422d364233422d343738332d393537322d4143423746333632314641432e706e67.png\"></p>\n<h3 id=\"联想\"><a href=\"#联想\" class=\"headerlink\" title=\"联想\"></a>联想</h3><p>按照这种设计架构的方式很多层面的东西都会渐渐的用描述解决，开发一套东西需要的是脚本描述。核心引擎好了，想想人工智能是不是不断积累数据，产出脚本描述然后不断的自动写代码给自己打patch（随便一说扯扯淡）。。。。</p>"},{"title":"IOS百行代码全局语言本地化/国际化","date":"2017-02-14T18:09:05.000Z","_content":"\n# IOS百行代码全局语言本地化/国际化\n废话不多说先把基本配置搞定图文一起来\n\n![3618569F-C518-4582-8580-9DC73F1E8B2E.png](http://upload-images.jianshu.io/upload_images/3994053-006976bd750f8324.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里点个“+”直接就o了\n剩下的就是创建strings文件也就是语言映射文件\n\n![32E018FA-1E4C-4127-BD87-0AE0B0B1641D.png](http://upload-images.jianshu.io/upload_images/3994053-6172f40aabb17548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n划线的就是创建时候该点击的InfoPlist.strings就是定义CFBundleDisplayName来确定app的名字\nLocalizable.strings则是正经的语言映射表了\nxib，storyboard和image也是一个套路看划线那点击就ok了\n![6DCE952A-4868-4652-AAB5-59C36DF129D5.png](http://upload-images.jianshu.io/upload_images/3994053-f2f6768c6d73d371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 百行代码全局Hook完成本地化\n废话不多说先放代码在解释\nhttps://github.com/heroims/LocalizedEngine\n<!-- more -->\n```Objective-C\n#import \"LocalizedEngine.h\"\n#import <objc/runtime.h>\n#import <UIKit/UIKit.h>\n\n#define LocalizedString(string) NSLocalizedString(string, nil)\n\n@interface NSObject (LocalizedEngineSwizzling)\n\n@end\n@implementation NSObject (LocalizedEngineSwizzling)\n\n+ (BOOL)les_swizzleMethod:(SEL)origSel withMethod:(SEL)altSel {\nMethod origMethod = class_getInstanceMethod(self, origSel);\nMethod altMethod = class_getInstanceMethod(self, altSel);\nif (!origMethod || !altMethod) {\nreturn NO;\n}\nclass_addMethod(self,\norigSel,\nclass_getMethodImplementation(self, origSel),\nmethod_getTypeEncoding(origMethod));\nclass_addMethod(self,\naltSel,\nclass_getMethodImplementation(self, altSel),\nmethod_getTypeEncoding(altMethod));\nmethod_exchangeImplementations(class_getInstanceMethod(self, origSel),\nclass_getInstanceMethod(self, altSel));\nreturn YES;\n}\n\n+ (BOOL)les_swizzleClassMethod:(SEL)origSel withMethod:(SEL)altSel {\nreturn [object_getClass((id)self) les_swizzleMethod:origSel withMethod:altSel];\n}\n\n@end\n\n@interface NSString (LocalizedEngine)\n\n@end\n\n@implementation NSString(LocalizedEngine)\n\n-(CGRect)le_boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary<NSString *, id> *)attributes context:(nullable NSStringDrawingContext *)context{\nreturn [LocalizedString(self) le_boundingRectWithSize:size options:options attributes:attributes context:context];\n}\n\n- (CGSize)le_sizeWithAttributes:(nullable NSDictionary<NSString *, id> *)attrs{\nreturn [LocalizedString(self) le_sizeWithAttributes:attrs];\n}\n@end\n\n@interface UILabel (LocalizedEngine)\n\n@end\n\n@implementation UILabel(LocalizedEngine)\n\n-(void)le_setText:(NSString *)text{\n[self le_setText:LocalizedString(text)];\n}\n\n@end\n\n@interface UITabBarItem (LocalizedEngine)\n\n@end\n@implementation UITabBarItem (LocalizedEngine)\n\n-(void)le_setTitle:(NSString *)title{\n[self le_setTitle:LocalizedString(title)];\n}\n\n@end\n\n@interface UIViewController (LocalizedEngine)\n\n@end\n@implementation UIViewController (LocalizedEngine)\n\n-(void)le_setTitle:(NSString *)title{\n[self le_setTitle:LocalizedString(title)];\n}\n\n@end\n\n@interface UIButton (LocalizedEngine)\n\n@end\n@implementation UIButton (LocalizedEngine)\n\n-(void)le_setTitle:(NSString *)title forState:(UIControlState)state{\n[self le_setTitle:LocalizedString(title) forState:state];\n}\n\n@end\n\n@implementation LocalizedEngine\n\n+(void)startEngine{\n[[UILabel class] les_swizzleMethod:@selector(setText:) withMethod:@selector(le_setText:)];\n[[UITabBarItem class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];\n[[UIViewController class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];\n[[UIButton class] les_swizzleMethod:@selector(setTitle:forState:) withMethod:@selector(le_setTitle:forState:)];\n[[NSString class] les_swizzleMethod:@selector(boundingRectWithSize:options:attributes:context:) withMethod:@selector(le_boundingRectWithSize:options:attributes:context:)];\n[[NSString class] les_swizzleMethod:@selector(sizeWithAttributes:) withMethod:@selector(le_sizeWithAttributes:)];\n\n\n}\n\n@end\n```\n\n调用只需要一句话\n[LocalizedEngine startEngine];\n其实只对UILabel做一次全局的文本就都被替换了，另一方面就是NSString对可变宽高的处理，这两个就已经解决了大部分需求，只不过后来发现系统控件在传递文本时做了布局的自适应，所以就有了UITabBarItem UIButton UIViewController的扩展，\n根据自己APP情况适当调整即可，包括NSAttributedString 细化出来这些估计也不会超过200行，上边放出的是初版，.m总共100行冒头，轻轻松松省去慢慢找位置加，有人找你做本地化，从此只需要做好string对照表即可，让人按格式给你。\n这只是利用AOP这种面向切面开发的思想解决问题的实例，同样的道理，风格扩展，日志，crash防御都能很好的独立且省事的完成。\n后续还将放一篇AOPLogger的讲讲\n","source":"_posts/IOS本地化:国际化项目配置.md","raw":"---\ntitle: IOS百行代码全局语言本地化/国际化\ndate: 2017-02-15 02:09:05\ntags:\n---\n\n# IOS百行代码全局语言本地化/国际化\n废话不多说先把基本配置搞定图文一起来\n\n![3618569F-C518-4582-8580-9DC73F1E8B2E.png](http://upload-images.jianshu.io/upload_images/3994053-006976bd750f8324.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里点个“+”直接就o了\n剩下的就是创建strings文件也就是语言映射文件\n\n![32E018FA-1E4C-4127-BD87-0AE0B0B1641D.png](http://upload-images.jianshu.io/upload_images/3994053-6172f40aabb17548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n划线的就是创建时候该点击的InfoPlist.strings就是定义CFBundleDisplayName来确定app的名字\nLocalizable.strings则是正经的语言映射表了\nxib，storyboard和image也是一个套路看划线那点击就ok了\n![6DCE952A-4868-4652-AAB5-59C36DF129D5.png](http://upload-images.jianshu.io/upload_images/3994053-f2f6768c6d73d371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 百行代码全局Hook完成本地化\n废话不多说先放代码在解释\nhttps://github.com/heroims/LocalizedEngine\n<!-- more -->\n```Objective-C\n#import \"LocalizedEngine.h\"\n#import <objc/runtime.h>\n#import <UIKit/UIKit.h>\n\n#define LocalizedString(string) NSLocalizedString(string, nil)\n\n@interface NSObject (LocalizedEngineSwizzling)\n\n@end\n@implementation NSObject (LocalizedEngineSwizzling)\n\n+ (BOOL)les_swizzleMethod:(SEL)origSel withMethod:(SEL)altSel {\nMethod origMethod = class_getInstanceMethod(self, origSel);\nMethod altMethod = class_getInstanceMethod(self, altSel);\nif (!origMethod || !altMethod) {\nreturn NO;\n}\nclass_addMethod(self,\norigSel,\nclass_getMethodImplementation(self, origSel),\nmethod_getTypeEncoding(origMethod));\nclass_addMethod(self,\naltSel,\nclass_getMethodImplementation(self, altSel),\nmethod_getTypeEncoding(altMethod));\nmethod_exchangeImplementations(class_getInstanceMethod(self, origSel),\nclass_getInstanceMethod(self, altSel));\nreturn YES;\n}\n\n+ (BOOL)les_swizzleClassMethod:(SEL)origSel withMethod:(SEL)altSel {\nreturn [object_getClass((id)self) les_swizzleMethod:origSel withMethod:altSel];\n}\n\n@end\n\n@interface NSString (LocalizedEngine)\n\n@end\n\n@implementation NSString(LocalizedEngine)\n\n-(CGRect)le_boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary<NSString *, id> *)attributes context:(nullable NSStringDrawingContext *)context{\nreturn [LocalizedString(self) le_boundingRectWithSize:size options:options attributes:attributes context:context];\n}\n\n- (CGSize)le_sizeWithAttributes:(nullable NSDictionary<NSString *, id> *)attrs{\nreturn [LocalizedString(self) le_sizeWithAttributes:attrs];\n}\n@end\n\n@interface UILabel (LocalizedEngine)\n\n@end\n\n@implementation UILabel(LocalizedEngine)\n\n-(void)le_setText:(NSString *)text{\n[self le_setText:LocalizedString(text)];\n}\n\n@end\n\n@interface UITabBarItem (LocalizedEngine)\n\n@end\n@implementation UITabBarItem (LocalizedEngine)\n\n-(void)le_setTitle:(NSString *)title{\n[self le_setTitle:LocalizedString(title)];\n}\n\n@end\n\n@interface UIViewController (LocalizedEngine)\n\n@end\n@implementation UIViewController (LocalizedEngine)\n\n-(void)le_setTitle:(NSString *)title{\n[self le_setTitle:LocalizedString(title)];\n}\n\n@end\n\n@interface UIButton (LocalizedEngine)\n\n@end\n@implementation UIButton (LocalizedEngine)\n\n-(void)le_setTitle:(NSString *)title forState:(UIControlState)state{\n[self le_setTitle:LocalizedString(title) forState:state];\n}\n\n@end\n\n@implementation LocalizedEngine\n\n+(void)startEngine{\n[[UILabel class] les_swizzleMethod:@selector(setText:) withMethod:@selector(le_setText:)];\n[[UITabBarItem class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];\n[[UIViewController class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];\n[[UIButton class] les_swizzleMethod:@selector(setTitle:forState:) withMethod:@selector(le_setTitle:forState:)];\n[[NSString class] les_swizzleMethod:@selector(boundingRectWithSize:options:attributes:context:) withMethod:@selector(le_boundingRectWithSize:options:attributes:context:)];\n[[NSString class] les_swizzleMethod:@selector(sizeWithAttributes:) withMethod:@selector(le_sizeWithAttributes:)];\n\n\n}\n\n@end\n```\n\n调用只需要一句话\n[LocalizedEngine startEngine];\n其实只对UILabel做一次全局的文本就都被替换了，另一方面就是NSString对可变宽高的处理，这两个就已经解决了大部分需求，只不过后来发现系统控件在传递文本时做了布局的自适应，所以就有了UITabBarItem UIButton UIViewController的扩展，\n根据自己APP情况适当调整即可，包括NSAttributedString 细化出来这些估计也不会超过200行，上边放出的是初版，.m总共100行冒头，轻轻松松省去慢慢找位置加，有人找你做本地化，从此只需要做好string对照表即可，让人按格式给你。\n这只是利用AOP这种面向切面开发的思想解决问题的实例，同样的道理，风格扩展，日志，crash防御都能很好的独立且省事的完成。\n后续还将放一篇AOPLogger的讲讲\n","slug":"IOS本地化:国际化项目配置","published":1,"updated":"2017-08-13T20:30:54.000Z","_id":"cj6b62e0z0003u16ag2b7rl9l","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"IOS百行代码全局语言本地化-国际化\"><a href=\"#IOS百行代码全局语言本地化-国际化\" class=\"headerlink\" title=\"IOS百行代码全局语言本地化/国际化\"></a>IOS百行代码全局语言本地化/国际化</h1><p>废话不多说先把基本配置搞定图文一起来</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3994053-006976bd750f8324.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3618569F-C518-4582-8580-9DC73F1E8B2E.png\"><br>这里点个“+”直接就o了<br>剩下的就是创建strings文件也就是语言映射文件</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3994053-6172f40aabb17548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"32E018FA-1E4C-4127-BD87-0AE0B0B1641D.png\"></p>\n<p>划线的就是创建时候该点击的InfoPlist.strings就是定义CFBundleDisplayName来确定app的名字<br>Localizable.strings则是正经的语言映射表了<br>xib，storyboard和image也是一个套路看划线那点击就ok了<br><img src=\"http://upload-images.jianshu.io/upload_images/3994053-f2f6768c6d73d371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6DCE952A-4868-4652-AAB5-59C36DF129D5.png\"></p>\n<h1 id=\"百行代码全局Hook完成本地化\"><a href=\"#百行代码全局Hook完成本地化\" class=\"headerlink\" title=\"百行代码全局Hook完成本地化\"></a>百行代码全局Hook完成本地化</h1><p>废话不多说先放代码在解释<br><a href=\"https://github.com/heroims/LocalizedEngine\" target=\"_blank\" rel=\"external\">https://github.com/heroims/LocalizedEngine</a><br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;LocalizedEngine.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define LocalizedString(string) NSLocalizedString(string, nil)</div><div class=\"line\"></div><div class=\"line\">@interface NSObject (LocalizedEngineSwizzling)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation NSObject (LocalizedEngineSwizzling)</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)les_swizzleMethod:(SEL)origSel withMethod:(SEL)altSel &#123;</div><div class=\"line\">Method origMethod = class_getInstanceMethod(self, origSel);</div><div class=\"line\">Method altMethod = class_getInstanceMethod(self, altSel);</div><div class=\"line\">if (!origMethod || !altMethod) &#123;</div><div class=\"line\">return NO;</div><div class=\"line\">&#125;</div><div class=\"line\">class_addMethod(self,</div><div class=\"line\">origSel,</div><div class=\"line\">class_getMethodImplementation(self, origSel),</div><div class=\"line\">method_getTypeEncoding(origMethod));</div><div class=\"line\">class_addMethod(self,</div><div class=\"line\">altSel,</div><div class=\"line\">class_getMethodImplementation(self, altSel),</div><div class=\"line\">method_getTypeEncoding(altMethod));</div><div class=\"line\">method_exchangeImplementations(class_getInstanceMethod(self, origSel),</div><div class=\"line\">class_getInstanceMethod(self, altSel));</div><div class=\"line\">return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)les_swizzleClassMethod:(SEL)origSel withMethod:(SEL)altSel &#123;</div><div class=\"line\">return [object_getClass((id)self) les_swizzleMethod:origSel withMethod:altSel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface NSString (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSString(LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(CGRect)le_boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context&#123;</div><div class=\"line\">return [LocalizedString(self) le_boundingRectWithSize:size options:options attributes:attributes context:context];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (CGSize)le_sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs&#123;</div><div class=\"line\">return [LocalizedString(self) le_sizeWithAttributes:attrs];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UILabel (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation UILabel(LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setText:(NSString *)text&#123;</div><div class=\"line\">[self le_setText:LocalizedString(text)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UITabBarItem (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation UITabBarItem (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setTitle:(NSString *)title&#123;</div><div class=\"line\">[self le_setTitle:LocalizedString(title)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UIViewController (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation UIViewController (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setTitle:(NSString *)title&#123;</div><div class=\"line\">[self le_setTitle:LocalizedString(title)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UIButton (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation UIButton (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setTitle:(NSString *)title forState:(UIControlState)state&#123;</div><div class=\"line\">[self le_setTitle:LocalizedString(title) forState:state];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation LocalizedEngine</div><div class=\"line\"></div><div class=\"line\">+(void)startEngine&#123;</div><div class=\"line\">[[UILabel class] les_swizzleMethod:@selector(setText:) withMethod:@selector(le_setText:)];</div><div class=\"line\">[[UITabBarItem class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];</div><div class=\"line\">[[UIViewController class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];</div><div class=\"line\">[[UIButton class] les_swizzleMethod:@selector(setTitle:forState:) withMethod:@selector(le_setTitle:forState:)];</div><div class=\"line\">[[NSString class] les_swizzleMethod:@selector(boundingRectWithSize:options:attributes:context:) withMethod:@selector(le_boundingRectWithSize:options:attributes:context:)];</div><div class=\"line\">[[NSString class] les_swizzleMethod:@selector(sizeWithAttributes:) withMethod:@selector(le_sizeWithAttributes:)];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>调用只需要一句话<br>[LocalizedEngine startEngine];<br>其实只对UILabel做一次全局的文本就都被替换了，另一方面就是NSString对可变宽高的处理，这两个就已经解决了大部分需求，只不过后来发现系统控件在传递文本时做了布局的自适应，所以就有了UITabBarItem UIButton UIViewController的扩展，<br>根据自己APP情况适当调整即可，包括NSAttributedString 细化出来这些估计也不会超过200行，上边放出的是初版，.m总共100行冒头，轻轻松松省去慢慢找位置加，有人找你做本地化，从此只需要做好string对照表即可，让人按格式给你。<br>这只是利用AOP这种面向切面开发的思想解决问题的实例，同样的道理，风格扩展，日志，crash防御都能很好的独立且省事的完成。<br>后续还将放一篇AOPLogger的讲讲</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"IOS百行代码全局语言本地化-国际化\"><a href=\"#IOS百行代码全局语言本地化-国际化\" class=\"headerlink\" title=\"IOS百行代码全局语言本地化/国际化\"></a>IOS百行代码全局语言本地化/国际化</h1><p>废话不多说先把基本配置搞定图文一起来</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3994053-006976bd750f8324.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3618569F-C518-4582-8580-9DC73F1E8B2E.png\"><br>这里点个“+”直接就o了<br>剩下的就是创建strings文件也就是语言映射文件</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3994053-6172f40aabb17548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"32E018FA-1E4C-4127-BD87-0AE0B0B1641D.png\"></p>\n<p>划线的就是创建时候该点击的InfoPlist.strings就是定义CFBundleDisplayName来确定app的名字<br>Localizable.strings则是正经的语言映射表了<br>xib，storyboard和image也是一个套路看划线那点击就ok了<br><img src=\"http://upload-images.jianshu.io/upload_images/3994053-f2f6768c6d73d371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6DCE952A-4868-4652-AAB5-59C36DF129D5.png\"></p>\n<h1 id=\"百行代码全局Hook完成本地化\"><a href=\"#百行代码全局Hook完成本地化\" class=\"headerlink\" title=\"百行代码全局Hook完成本地化\"></a>百行代码全局Hook完成本地化</h1><p>废话不多说先放代码在解释<br><a href=\"https://github.com/heroims/LocalizedEngine\" target=\"_blank\" rel=\"external\">https://github.com/heroims/LocalizedEngine</a><br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;LocalizedEngine.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define LocalizedString(string) NSLocalizedString(string, nil)</div><div class=\"line\"></div><div class=\"line\">@interface NSObject (LocalizedEngineSwizzling)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation NSObject (LocalizedEngineSwizzling)</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)les_swizzleMethod:(SEL)origSel withMethod:(SEL)altSel &#123;</div><div class=\"line\">Method origMethod = class_getInstanceMethod(self, origSel);</div><div class=\"line\">Method altMethod = class_getInstanceMethod(self, altSel);</div><div class=\"line\">if (!origMethod || !altMethod) &#123;</div><div class=\"line\">return NO;</div><div class=\"line\">&#125;</div><div class=\"line\">class_addMethod(self,</div><div class=\"line\">origSel,</div><div class=\"line\">class_getMethodImplementation(self, origSel),</div><div class=\"line\">method_getTypeEncoding(origMethod));</div><div class=\"line\">class_addMethod(self,</div><div class=\"line\">altSel,</div><div class=\"line\">class_getMethodImplementation(self, altSel),</div><div class=\"line\">method_getTypeEncoding(altMethod));</div><div class=\"line\">method_exchangeImplementations(class_getInstanceMethod(self, origSel),</div><div class=\"line\">class_getInstanceMethod(self, altSel));</div><div class=\"line\">return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)les_swizzleClassMethod:(SEL)origSel withMethod:(SEL)altSel &#123;</div><div class=\"line\">return [object_getClass((id)self) les_swizzleMethod:origSel withMethod:altSel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface NSString (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSString(LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(CGRect)le_boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context&#123;</div><div class=\"line\">return [LocalizedString(self) le_boundingRectWithSize:size options:options attributes:attributes context:context];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (CGSize)le_sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs&#123;</div><div class=\"line\">return [LocalizedString(self) le_sizeWithAttributes:attrs];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UILabel (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation UILabel(LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setText:(NSString *)text&#123;</div><div class=\"line\">[self le_setText:LocalizedString(text)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UITabBarItem (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation UITabBarItem (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setTitle:(NSString *)title&#123;</div><div class=\"line\">[self le_setTitle:LocalizedString(title)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UIViewController (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation UIViewController (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setTitle:(NSString *)title&#123;</div><div class=\"line\">[self le_setTitle:LocalizedString(title)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface UIButton (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation UIButton (LocalizedEngine)</div><div class=\"line\"></div><div class=\"line\">-(void)le_setTitle:(NSString *)title forState:(UIControlState)state&#123;</div><div class=\"line\">[self le_setTitle:LocalizedString(title) forState:state];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation LocalizedEngine</div><div class=\"line\"></div><div class=\"line\">+(void)startEngine&#123;</div><div class=\"line\">[[UILabel class] les_swizzleMethod:@selector(setText:) withMethod:@selector(le_setText:)];</div><div class=\"line\">[[UITabBarItem class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];</div><div class=\"line\">[[UIViewController class] les_swizzleMethod:@selector(setTitle:) withMethod:@selector(le_setTitle:)];</div><div class=\"line\">[[UIButton class] les_swizzleMethod:@selector(setTitle:forState:) withMethod:@selector(le_setTitle:forState:)];</div><div class=\"line\">[[NSString class] les_swizzleMethod:@selector(boundingRectWithSize:options:attributes:context:) withMethod:@selector(le_boundingRectWithSize:options:attributes:context:)];</div><div class=\"line\">[[NSString class] les_swizzleMethod:@selector(sizeWithAttributes:) withMethod:@selector(le_sizeWithAttributes:)];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>调用只需要一句话<br>[LocalizedEngine startEngine];<br>其实只对UILabel做一次全局的文本就都被替换了，另一方面就是NSString对可变宽高的处理，这两个就已经解决了大部分需求，只不过后来发现系统控件在传递文本时做了布局的自适应，所以就有了UITabBarItem UIButton UIViewController的扩展，<br>根据自己APP情况适当调整即可，包括NSAttributedString 细化出来这些估计也不会超过200行，上边放出的是初版，.m总共100行冒头，轻轻松松省去慢慢找位置加，有人找你做本地化，从此只需要做好string对照表即可，让人按格式给你。<br>这只是利用AOP这种面向切面开发的思想解决问题的实例，同样的道理，风格扩展，日志，crash防御都能很好的独立且省事的完成。<br>后续还将放一篇AOPLogger的讲讲</p>"},{"title":"IOS组件化与工程管理","date":"2017-02-04T18:09:05.000Z","_content":"\n谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。\n# 工程管理\n组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。\n理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？\n因为submodule本身就是git自带的就是git的一部分，常用命令有\n``` \n# 添加子仓库\ngit submodule add 仓库地址 路径\n#初始化所有子仓库\ngit submodule init\n# 更新子仓库\ngit submodule update\n\n# 也可以初始化更新一起\ngit submodule update --init\n```\n\npod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。\n当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。\n上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。\n\n这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立\n```\nPod::Spec.new do |s|\ns.name                  = 'MainWorkSpaceDemo'\ns.version               = '1.0.0'\ns.summary               = 'A new container controller to slide  '\ns.homepage              = 'github.com'\ns.license               = { :type => 'MIT', :file => 'README.md' }\ns.author                = { 'heroims' => 'heroims@163.com' }\ns.source                = { :git => '', :tag => \"#{s.version}\" }\ns.platform              = :ios, '5.0'\ns.source_files          = 'ZYQRouter/*.{h,m}'\ns.requires_arc          = true\n#公共仓库\ns.subspec 'BaseTool' do |ss|\nss.source_files = 'ZYQRouter/*.{h,m}'\nend\n#模块1\ns.subspec 'Module1' do |sss|\nsss.source_files = 'Module1/Module1Lib/*.{h,m}'\nend\n#模块2\ns.subspec 'Module2' do |ssss|\nssss.source_files = 'Module2/Module2Lib/*.{h,m}'\nend\n\nend\n```\n看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便\n然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽\n```\ntarget 'Module1' do\n# Uncomment the next line if you're using Swift or would like to use dynamic frameworks\n# use_frameworks!\n\n# Pods for Module1\npod 'MainWorkSpaceDemo/BaseTool', :path => '../MainWorkSpaceDemo.podspec'\n\ntarget 'Module1Tests' do\ninherit! :search_paths\n# Pods for testing\nend\n\ntarget 'Module1UITests' do\ninherit! :search_paths\n# Pods for testing\nend\n\nend\n```\n<!-- more -->\n就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了\n下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。\n顺便放一下我的ZYQRouter：https://github.com/heroims/ZYQRouter\n里面的demo虽然没用submodule但基本可以阐述完整这套东西。\n正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。\n这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。\n# 页面路由\n关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候\n则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。\n\n顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。\n而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。\n但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。\n另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式\n\n\n```Objective-C\n/**\n重定向 URLPattern 到对应的 newURLPattern \n@param URLPattern 原scheme\n@param newURLPattern 新scheme\n*/\n+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;\n\n/**\n*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;\n\n/**\n*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*                    自带的 key 为 @\"url\" 和 @\"completion\" (如果有的话)\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;\n\n/**\n*  取消注册某个 URL Pattern\n*\n*  @param URLPattern\n*/\n+ (void)deregisterURLPattern:(NSString *)URLPattern;\n\n/**\n*  打开此 URL\n*  会在已注册的 URL -> Handler 中寻找，如果找到，则执行 Handler\n*\n*  @param URL 带 Scheme，如 applink://beauty/3\n*/\n+ (void)openURL:(NSString *)URL;\n\n/**\n*  打开此 URL，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;\n\n/**\n*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param parameters 附加参数\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*/\n+ (id)objectForURL:(NSString *)URL;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*  @param userInfo\n*/\n+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;\n\n/**\n*  是否可以打开URL\n*\n*  @param URL\n*\n*  @return\n*/\n+ (BOOL)canOpenURL:(NSString *)URL;\n\n/**\n*  调用此方法来拼接 urlpattern 和 parameters\n*\n*  #define ROUTE_BEAUTY @\"beauty/:id\"\n*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];\n*\n*\n*  @param pattern    url pattern 比如 @\"beauty/:id\"\n*  @param parameters 一个数组，数量要跟 pattern 里的变量一致\n*\n*  @return\n*/\n+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;\n```\n\n# 方法路由\n关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。\n```Objective-C\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param objectsArr   参数数组 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;\n\n/**\n*\n*  添加未找到Target 或 Action 逻辑\n*\n*  @param notFoundHandler    未找到方法回调\n*  @param targetName    类名\n*\n*  @return\n*/\n+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;\n\n/**\n*  删除Target缓存\n*\n*  @return\n*/\n+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;\n+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;\n+ (void)removeAllTargetsCache;\n\n/**\n不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）\nid result=(__bridge id)zyq_invokeSelectorObjects(@\"Class\", @\"actionWithObj1:obj2:obj3\",obj1,obj2,obj3,nil);\n\nc类型转换配合__bridge_transfer __bridge\n利用IMP返回值只是指针，不支持C基本类型\n\n@param className 类名\n@param selectorName,... 方法名，不定参数\n@return 返回值\n*/\nvoid * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);\n```\n最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。\n","source":"_posts/IOS组件化与工程管理.md","raw":"---\ntitle: IOS组件化与工程管理\ndate: 2017-02-05 02:09:05\ntags:\n---\n\n谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。\n# 工程管理\n组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。\n理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？\n因为submodule本身就是git自带的就是git的一部分，常用命令有\n``` \n# 添加子仓库\ngit submodule add 仓库地址 路径\n#初始化所有子仓库\ngit submodule init\n# 更新子仓库\ngit submodule update\n\n# 也可以初始化更新一起\ngit submodule update --init\n```\n\npod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。\n当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。\n上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。\n\n这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立\n```\nPod::Spec.new do |s|\ns.name                  = 'MainWorkSpaceDemo'\ns.version               = '1.0.0'\ns.summary               = 'A new container controller to slide  '\ns.homepage              = 'github.com'\ns.license               = { :type => 'MIT', :file => 'README.md' }\ns.author                = { 'heroims' => 'heroims@163.com' }\ns.source                = { :git => '', :tag => \"#{s.version}\" }\ns.platform              = :ios, '5.0'\ns.source_files          = 'ZYQRouter/*.{h,m}'\ns.requires_arc          = true\n#公共仓库\ns.subspec 'BaseTool' do |ss|\nss.source_files = 'ZYQRouter/*.{h,m}'\nend\n#模块1\ns.subspec 'Module1' do |sss|\nsss.source_files = 'Module1/Module1Lib/*.{h,m}'\nend\n#模块2\ns.subspec 'Module2' do |ssss|\nssss.source_files = 'Module2/Module2Lib/*.{h,m}'\nend\n\nend\n```\n看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便\n然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽\n```\ntarget 'Module1' do\n# Uncomment the next line if you're using Swift or would like to use dynamic frameworks\n# use_frameworks!\n\n# Pods for Module1\npod 'MainWorkSpaceDemo/BaseTool', :path => '../MainWorkSpaceDemo.podspec'\n\ntarget 'Module1Tests' do\ninherit! :search_paths\n# Pods for testing\nend\n\ntarget 'Module1UITests' do\ninherit! :search_paths\n# Pods for testing\nend\n\nend\n```\n<!-- more -->\n就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了\n下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。\n顺便放一下我的ZYQRouter：https://github.com/heroims/ZYQRouter\n里面的demo虽然没用submodule但基本可以阐述完整这套东西。\n正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。\n这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。\n# 页面路由\n关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候\n则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。\n\n顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。\n而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。\n但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。\n另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式\n\n\n```Objective-C\n/**\n重定向 URLPattern 到对应的 newURLPattern \n@param URLPattern 原scheme\n@param newURLPattern 新scheme\n*/\n+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;\n\n/**\n*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;\n\n/**\n*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方\n*\n*  @param URLPattern 带上 scheme，如 applink://beauty/:id\n*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。\n*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @{@\"id\": 4} 这样的字典过来\n*                    自带的 key 为 @\"url\" 和 @\"completion\" (如果有的话)\n*/\n+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;\n\n/**\n*  取消注册某个 URL Pattern\n*\n*  @param URLPattern\n*/\n+ (void)deregisterURLPattern:(NSString *)URLPattern;\n\n/**\n*  打开此 URL\n*  会在已注册的 URL -> Handler 中寻找，如果找到，则执行 Handler\n*\n*  @param URL 带 Scheme，如 applink://beauty/3\n*/\n+ (void)openURL:(NSString *)URL;\n\n/**\n*  打开此 URL，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;\n\n/**\n*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码\n*\n*  @param URL        带 Scheme 的 URL，如 applink://beauty/4\n*  @param parameters 附加参数\n*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关\n*/\n+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*/\n+ (id)objectForURL:(NSString *)URL;\n\n/**\n* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object\n*\n*  @param URL\n*  @param userInfo\n*/\n+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;\n\n/**\n*  是否可以打开URL\n*\n*  @param URL\n*\n*  @return\n*/\n+ (BOOL)canOpenURL:(NSString *)URL;\n\n/**\n*  调用此方法来拼接 urlpattern 和 parameters\n*\n*  #define ROUTE_BEAUTY @\"beauty/:id\"\n*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];\n*\n*\n*  @param pattern    url pattern 比如 @\"beauty/:id\"\n*  @param parameters 一个数组，数量要跟 pattern 里的变量一致\n*\n*  @return\n*/\n+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;\n```\n\n# 方法路由\n关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。\n```Objective-C\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param object1,... 不定参数 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;\n\n/**\n*\n*  调度工程内的组件方法\n*  [ZYQRouter performTarget:@\"xxxClass\" action:@\"xxxxActionWithObj1:obj2:obj3\" shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]\n*  内部自动 alloc init 初始化对象\n*\n*  @param targetName    执行方法的类\n*  @param actionName    方法名\n*  @param shouldCacheTaget   设置target缓存\n*  @param objectsArr   参数数组 不支持C基本类型\n*\n*  @return 方法回参\n*/\n+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;\n\n/**\n*\n*  添加未找到Target 或 Action 逻辑\n*\n*  @param notFoundHandler    未找到方法回调\n*  @param targetName    类名\n*\n*  @return\n*/\n+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;\n\n/**\n*  删除Target缓存\n*\n*  @return\n*/\n+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;\n+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;\n+ (void)removeAllTargetsCache;\n\n/**\n不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）\nid result=(__bridge id)zyq_invokeSelectorObjects(@\"Class\", @\"actionWithObj1:obj2:obj3\",obj1,obj2,obj3,nil);\n\nc类型转换配合__bridge_transfer __bridge\n利用IMP返回值只是指针，不支持C基本类型\n\n@param className 类名\n@param selectorName,... 方法名，不定参数\n@return 返回值\n*/\nvoid * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);\n```\n最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。\n","slug":"IOS组件化与工程管理","published":1,"updated":"2017-08-13T20:31:11.000Z","_id":"cj6b62e120004u16ahv1x6x52","comments":1,"layout":"post","photos":[],"link":"","content":"<p>谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。</p>\n<h1 id=\"工程管理\"><a href=\"#工程管理\" class=\"headerlink\" title=\"工程管理\"></a>工程管理</h1><p>组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。<br>理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？<br>因为submodule本身就是git自带的就是git的一部分，常用命令有<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 添加子仓库</div><div class=\"line\">git submodule add 仓库地址 路径</div><div class=\"line\">#初始化所有子仓库</div><div class=\"line\">git submodule init</div><div class=\"line\"># 更新子仓库</div><div class=\"line\">git submodule update</div><div class=\"line\"></div><div class=\"line\"># 也可以初始化更新一起</div><div class=\"line\">git submodule update --init</div></pre></td></tr></table></figure></p>\n<p>pod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。<br>当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。<br>上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。</p>\n<p>这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\">s.name                  = &apos;MainWorkSpaceDemo&apos;</div><div class=\"line\">s.version               = &apos;1.0.0&apos;</div><div class=\"line\">s.summary               = &apos;A new container controller to slide  &apos;</div><div class=\"line\">s.homepage              = &apos;github.com&apos;</div><div class=\"line\">s.license               = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;README.md&apos; &#125;</div><div class=\"line\">s.author                = &#123; &apos;heroims&apos; =&gt; &apos;heroims@163.com&apos; &#125;</div><div class=\"line\">s.source                = &#123; :git =&gt; &apos;&apos;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class=\"line\">s.platform              = :ios, &apos;5.0&apos;</div><div class=\"line\">s.source_files          = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">s.requires_arc          = true</div><div class=\"line\">#公共仓库</div><div class=\"line\">s.subspec &apos;BaseTool&apos; do |ss|</div><div class=\"line\">ss.source_files = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块1</div><div class=\"line\">s.subspec &apos;Module1&apos; do |sss|</div><div class=\"line\">sss.source_files = &apos;Module1/Module1Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块2</div><div class=\"line\">s.subspec &apos;Module2&apos; do |ssss|</div><div class=\"line\">ssss.source_files = &apos;Module2/Module2Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便<br>然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">target &apos;Module1&apos; do</div><div class=\"line\"># Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</div><div class=\"line\"># use_frameworks!</div><div class=\"line\"></div><div class=\"line\"># Pods for Module1</div><div class=\"line\">pod &apos;MainWorkSpaceDemo/BaseTool&apos;, :path =&gt; &apos;../MainWorkSpaceDemo.podspec&apos;</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1Tests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1UITests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了<br>下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。<br>顺便放一下我的ZYQRouter：<a href=\"https://github.com/heroims/ZYQRouter\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ZYQRouter</a><br>里面的demo虽然没用submodule但基本可以阐述完整这套东西。<br>正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。<br>这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。</p>\n<h1 id=\"页面路由\"><a href=\"#页面路由\" class=\"headerlink\" title=\"页面路由\"></a>页面路由</h1><p>关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候<br>则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。</p>\n<p>顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。<br>而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。<br>但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。<br>另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">重定向 URLPattern 到对应的 newURLPattern </div><div class=\"line\">@param URLPattern 原scheme</div><div class=\"line\">@param newURLPattern 新scheme</div><div class=\"line\">*/</div><div class=\"line\">+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*                    自带的 key 为 @&quot;url&quot; 和 @&quot;completion&quot; (如果有的话)</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  取消注册某个 URL Pattern</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern</div><div class=\"line\">*/</div><div class=\"line\">+ (void)deregisterURLPattern:(NSString *)URLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL</div><div class=\"line\">*  会在已注册的 URL -&gt; Handler 中寻找，如果找到，则执行 Handler</div><div class=\"line\">*</div><div class=\"line\">*  @param URL 带 Scheme，如 applink://beauty/3</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param parameters 附加参数</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*  @param userInfo</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  是否可以打开URL</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (BOOL)canOpenURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  调用此方法来拼接 urlpattern 和 parameters</div><div class=\"line\">*</div><div class=\"line\">*  #define ROUTE_BEAUTY @&quot;beauty/:id&quot;</div><div class=\"line\">*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];</div><div class=\"line\">*</div><div class=\"line\">*</div><div class=\"line\">*  @param pattern    url pattern 比如 @&quot;beauty/:id&quot;</div><div class=\"line\">*  @param parameters 一个数组，数量要跟 pattern 里的变量一致</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;</div></pre></td></tr></table></figure>\n<h1 id=\"方法路由\"><a href=\"#方法路由\" class=\"headerlink\" title=\"方法路由\"></a>方法路由</h1><p>关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param objectsArr   参数数组 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  添加未找到Target 或 Action 逻辑</div><div class=\"line\">*</div><div class=\"line\">*  @param notFoundHandler    未找到方法回调</div><div class=\"line\">*  @param targetName    类名</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  删除Target缓存</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;</div><div class=\"line\">+ (void)removeAllTargetsCache;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）</div><div class=\"line\">id result=(__bridge id)zyq_invokeSelectorObjects(@&quot;Class&quot;, @&quot;actionWithObj1:obj2:obj3&quot;,obj1,obj2,obj3,nil);</div><div class=\"line\"></div><div class=\"line\">c类型转换配合__bridge_transfer __bridge</div><div class=\"line\">利用IMP返回值只是指针，不支持C基本类型</div><div class=\"line\"></div><div class=\"line\">@param className 类名</div><div class=\"line\">@param selectorName,... 方法名，不定参数</div><div class=\"line\">@return 返回值</div><div class=\"line\">*/</div><div class=\"line\">void * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);</div></pre></td></tr></table></figure></p>\n<p>最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。</p>\n","site":{"data":{}},"excerpt":"<p>谈及组件化其实网上也有不少文章了，但我个人认为不结合工程管理去单讲组件化恐怕很难让人理解概念，而去实践的时候也只是照猫画虎。</p>\n<h1 id=\"工程管理\"><a href=\"#工程管理\" class=\"headerlink\" title=\"工程管理\"></a>工程管理</h1><p>组件化的实现很重要的一个组成部分应该是工程拆分，这里我的方案是采取git管理项目pod管理依赖很常见很普通的方法。<br>理想的状态每一个模块都是独立的，可以单独拿出来测试，发布，也就是每一个子模块其实都是一个git仓库，这里紧接着就是子仓库和主项目的关系问题，上边说到了git和pod，还有一个submodule我喜欢用这个来做子仓库的管理上边为啥没提它呢？<br>因为submodule本身就是git自带的就是git的一部分，常用命令有<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 添加子仓库</div><div class=\"line\">git submodule add 仓库地址 路径</div><div class=\"line\">#初始化所有子仓库</div><div class=\"line\">git submodule init</div><div class=\"line\"># 更新子仓库</div><div class=\"line\">git submodule update</div><div class=\"line\"></div><div class=\"line\"># 也可以初始化更新一起</div><div class=\"line\">git submodule update --init</div></pre></td></tr></table></figure></p>\n<p>pod只是帮我把依赖关系理清直接本地pod，因为坑爹的开发阶段难免有互相block的情况，那边东西弄完了，但还没有做发布还不稳定，但另一边已经急着要看一眼整体调用的效果了。。。<br>当然这时候也可以让对面先打个beta的tag，那样可想而知最后会有多少没用的tag，另一方面就是bug联调恢复节点排查的时候，另一方估计只有一个方案就是回滚上一个tag中间哪的问题一点点打tag联调。<br>上边说的打tag也只是个例子，当然你可以改Podfile对应不同branch，但那也是要每次调都要改一下的，但我这种模式由于是本地pod所以podfile不用动了每次都去指向对应的项目，剩下的就是对子仓库随意切换branch甚至commit节点都可以，调ok了直接commit一下submodule指向的更改即可。然后另一方更新一下再pod update把依赖关系重新建立一下（如果没有添加或删除，甚至这步都不需要，本地pod引用目录我们submodule的本地文件夹里面有什么变化这边自动会变，添加删除是因为依赖关系发生变化了所以跟着需要重新建立）,当然理想情况回头有空单独整合一套submodule和pod的命令，submodule更新时判断有增删操作执行pod update其他情况不处理。</p>\n<p>这里紧接着就是公共库的处理以及怎么去建立主仓库与子仓库的依赖，我这里把基本思路给出，具体情况还是自己再改动，这里首先就是建立podspec来提供依赖建立<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\">s.name                  = &apos;MainWorkSpaceDemo&apos;</div><div class=\"line\">s.version               = &apos;1.0.0&apos;</div><div class=\"line\">s.summary               = &apos;A new container controller to slide  &apos;</div><div class=\"line\">s.homepage              = &apos;github.com&apos;</div><div class=\"line\">s.license               = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;README.md&apos; &#125;</div><div class=\"line\">s.author                = &#123; &apos;heroims&apos; =&gt; &apos;heroims@163.com&apos; &#125;</div><div class=\"line\">s.source                = &#123; :git =&gt; &apos;&apos;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class=\"line\">s.platform              = :ios, &apos;5.0&apos;</div><div class=\"line\">s.source_files          = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">s.requires_arc          = true</div><div class=\"line\">#公共仓库</div><div class=\"line\">s.subspec &apos;BaseTool&apos; do |ss|</div><div class=\"line\">ss.source_files = &apos;ZYQRouter/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块1</div><div class=\"line\">s.subspec &apos;Module1&apos; do |sss|</div><div class=\"line\">sss.source_files = &apos;Module1/Module1Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\">#模块2</div><div class=\"line\">s.subspec &apos;Module2&apos; do |ssss|</div><div class=\"line\">ssss.source_files = &apos;Module2/Module2Lib/*.&#123;h,m&#125;&apos;</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>看见上边相比就明白了把，开发的时候最好要作为模块给人的东西放在一个目录下，当然不放也可以，这里就是为了方便<br>然后就是引用了,下面是module1工程的，只引用了一个公共库，真正开发的时候则会引用很多，然后build测试模块的app给测试，提供给主仓库的东西放在事先约定的目录下，其他的随便看心情，反正对别人没影响就是自己爽不爽<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">target &apos;Module1&apos; do</div><div class=\"line\"># Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</div><div class=\"line\"># use_frameworks!</div><div class=\"line\"></div><div class=\"line\"># Pods for Module1</div><div class=\"line\">pod &apos;MainWorkSpaceDemo/BaseTool&apos;, :path =&gt; &apos;../MainWorkSpaceDemo.podspec&apos;</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1Tests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">target &apos;Module1UITests&apos; do</div><div class=\"line\">inherit! :search_paths</div><div class=\"line\"># Pods for testing</div><div class=\"line\">end</div><div class=\"line\"></div><div class=\"line\">end</div></pre></td></tr></table></figure></p>","more":"<p>就此基本的项目依赖思路构建就算讲完了，剩下的就是调用了，其实上边的东西你掌握好了，组件化就已经可以单用这种工程管理模式解决了<br>下面的就是大家能经常搜到的一些组件化的东西，在我看来剩下的只是锦上添花，工程管理好组件化才有真正意义。从开发的角度上不论开发什么用什么语言，组件化或者说模块化通用思路就是分离多个仓库然后自动化建立依赖关系，项目工程里互相调用适当的用反射的方法实现调用，基本上每一个小仓库就都能独立的运行了。<br>顺便放一下我的ZYQRouter：<a href=\"https://github.com/heroims/ZYQRouter\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ZYQRouter</a><br>里面的demo虽然没用submodule但基本可以阐述完整这套东西。<br>正式开始讲代码里的架构，ZYQRouter主要是方便各个模块之间的互相调用。之所以重复造轮子，其实只是自己项目需要，另外就是想完善这套组件化的实现。<br>这里ZYQRouter分为页面路由和方法路由，页面路由负责根据URL做各页面跳转甚至远程调度方法路由，方法路由则是提供target-action实例方法调用和invokeSelectorObjects反射调用静态方法，目的就是让各个模块开发过程中不引用对方的情况下也可独立按约定调用对方模块运行调试自己的相关内容，大家都开发完各个单元测试ok，集成到主项目里就可以基本跑通，当然现实是联调还是会通常出些小问题，但没什么大碍。</p>\n<h1 id=\"页面路由\"><a href=\"#页面路由\" class=\"headerlink\" title=\"页面路由\"></a>页面路由</h1><p>关于页面路由如下，用过蘑菇街Router的看这个会很亲切，我只是在它的基础上添加了重定向这个功能，这重定向的由来一个是动态更新页面跳转逻辑方便，另一个就是我们自己的需求客服系统里。。。。你会发现一个订单链接地址由客服发来，网页上用这链接用户打开的就是网页自己订单，客服打开就是客服系统该用户的订单，app上用户打开就是用户订单页面，于是救星就是重定向，把xxx.xxx.xxx/crm-order/orderid和xxx.xxx.xxx/order/orderid都重定向到applink://order/orderid，还有就是订单有大改动的时候<br>则是xxx.xxx.xxx/crm-order/orderid和applink://order/orderid重定向到xxx.xxx.xxx/order/orderid直接开网页用户订单，还有很多奇葩需求全靠重定向这救命稻草，所以这个重定向真的很实用。</p>\n<p>顺便再说下注册的事，因为我的Router里提供了target-action的调用所以上面说的远程调度target-action可以用一个url如applink://target-action/:target/:action?xxx=xxx完成，只用注册applink://target-action/:target/:action内部调用target-action方法。<br>而让所有部门全依照这一个逻辑规则产出链接简直天方夜谭，前端放在网页上的链接按这样估计一堆人吐槽，但仅仅ios部门之间按照这一规则跑还是可以的。<br>但当然有比较折中的方法，毕竟注册太多url也占地啊，这时候神奇的重定向就又可以上线救援了，如xxx.xxx.xxx/order?xxx=xxx这类直接重定向xxx.xxx.xxx/order到applink://target-action/ordertarget/orderaction这就好了，你注册的就可以少点但前提是你的target-action里处理的情况多。<br>另外写页面路由最好根据模块单独创建相应的类，比如Module1里可以单独的建个Module1PageFactory，有个方法-(void)openModule1VC1WithO1:(id)o1 o2:(id)o2 o3:(id)o3类似方法然后+(void)load里注册Router调用open的方法，这样开发阶段用方法路由，而在需要从外部进入时采用页面路由方式也就是URL方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">重定向 URLPattern 到对应的 newURLPattern </div><div class=\"line\">@param URLPattern 原scheme</div><div class=\"line\">@param newURLPattern 新scheme</div><div class=\"line\">*/</div><div class=\"line\">+ (void)redirectURLPattern:(NSString *)URLPattern toURLPattern:(NSString*)newURLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 Handler，在 handler 中可以初始化 VC，然后对 VC 做各种操作</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toHandler:(ZYQRouterHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  注册 URLPattern 对应的 ObjectHandler，需要返回一个 object 给调用方</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern 带上 scheme，如 applink://beauty/:id</div><div class=\"line\">*  @param handler    该 block 会传一个字典，包含了注册的 URL 中对应的变量。</div><div class=\"line\">*                    假如注册的 URL 为 applink://beauty/:id 那么，就会传一个 @&#123;@&quot;id&quot;: 4&#125; 这样的字典过来</div><div class=\"line\">*                    自带的 key 为 @&quot;url&quot; 和 @&quot;completion&quot; (如果有的话)</div><div class=\"line\">*/</div><div class=\"line\">+ (void)registerURLPattern:(NSString *)URLPattern toObjectHandler:(ZYQRouterObjectHandler)handler;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  取消注册某个 URL Pattern</div><div class=\"line\">*</div><div class=\"line\">*  @param URLPattern</div><div class=\"line\">*/</div><div class=\"line\">+ (void)deregisterURLPattern:(NSString *)URLPattern;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL</div><div class=\"line\">*  会在已注册的 URL -&gt; Handler 中寻找，如果找到，则执行 Handler</div><div class=\"line\">*</div><div class=\"line\">*  @param URL 带 Scheme，如 applink://beauty/3</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  打开此 URL，带上附加信息，同时当操作完成时，执行额外的代码</div><div class=\"line\">*</div><div class=\"line\">*  @param URL        带 Scheme 的 URL，如 applink://beauty/4</div><div class=\"line\">*  @param parameters 附加参数</div><div class=\"line\">*  @param completion URL 处理完成后的 callback，完成的判定跟具体的业务相关</div><div class=\"line\">*/</div><div class=\"line\">+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* 查找谁对某个 URL 感兴趣，如果有的话，返回一个 object</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*  @param userInfo</div><div class=\"line\">*/</div><div class=\"line\">+ (id)objectForURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  是否可以打开URL</div><div class=\"line\">*</div><div class=\"line\">*  @param URL</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (BOOL)canOpenURL:(NSString *)URL;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  调用此方法来拼接 urlpattern 和 parameters</div><div class=\"line\">*</div><div class=\"line\">*  #define ROUTE_BEAUTY @&quot;beauty/:id&quot;</div><div class=\"line\">*  [ZYQRouter generateURLWithPattern:ROUTE_BEAUTY, @[@13]];</div><div class=\"line\">*</div><div class=\"line\">*</div><div class=\"line\">*  @param pattern    url pattern 比如 @&quot;beauty/:id&quot;</div><div class=\"line\">*  @param parameters 一个数组，数量要跟 pattern 里的变量一致</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (NSString *)generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;</div></pre></td></tr></table></figure>\n<h1 id=\"方法路由\"><a href=\"#方法路由\" class=\"headerlink\" title=\"方法路由\"></a>方法路由</h1><p>关于方法路由如下,target-action模式就是自动根据class来alloc init初始化完target对象，然后@selector把那action方法调用了返回，而静态方法则是runtime搞定，日常需求基本满足，但还有点缺陷注释里已说明，由于invokeSelectorObjects根据className和selectorName调用静态方法所以封装成了C方法，另外就是这个不常用算是尝试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param object1,... 不定参数 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objects:(id)object1,...;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  调度工程内的组件方法</div><div class=\"line\">*  [ZYQRouter performTarget:@&quot;xxxClass&quot; action:@&quot;xxxxActionWithObj1:obj2:obj3&quot; shouldCacheTaget:YES objects:obj1,obj2,obj3,nil]</div><div class=\"line\">*  内部自动 alloc init 初始化对象</div><div class=\"line\">*</div><div class=\"line\">*  @param targetName    执行方法的类</div><div class=\"line\">*  @param actionName    方法名</div><div class=\"line\">*  @param shouldCacheTaget   设置target缓存</div><div class=\"line\">*  @param objectsArr   参数数组 不支持C基本类型</div><div class=\"line\">*</div><div class=\"line\">*  @return 方法回参</div><div class=\"line\">*/</div><div class=\"line\">+ (id)performTarget:(NSString*)targetName action:(NSString*)actionName shouldCacheTaget:(BOOL)shouldCacheTaget objectsArr:(NSArray*)objectsArr;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*</div><div class=\"line\">*  添加未找到Target 或 Action 逻辑</div><div class=\"line\">*</div><div class=\"line\">*  @param notFoundHandler    未找到方法回调</div><div class=\"line\">*  @param targetName    类名</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)addNotFoundHandler:(ZYQNotFoundTargetActionHandler)notFoundHandler targetName:(NSString*)targetName;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*  删除Target缓存</div><div class=\"line\">*</div><div class=\"line\">*  @return</div><div class=\"line\">*/</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetName:(NSString*)targetName;</div><div class=\"line\">+ (void)removeTargetsCacheWithTargetNames:(NSArray*)targetNames;</div><div class=\"line\">+ (void)removeAllTargetsCache;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">不定参静态方法调用 （最多支持7个，原因不定参方法传给不定参方法实在没啥好办法。。。。暂时如此）</div><div class=\"line\">id result=(__bridge id)zyq_invokeSelectorObjects(@&quot;Class&quot;, @&quot;actionWithObj1:obj2:obj3&quot;,obj1,obj2,obj3,nil);</div><div class=\"line\"></div><div class=\"line\">c类型转换配合__bridge_transfer __bridge</div><div class=\"line\">利用IMP返回值只是指针，不支持C基本类型</div><div class=\"line\"></div><div class=\"line\">@param className 类名</div><div class=\"line\">@param selectorName,... 方法名，不定参数</div><div class=\"line\">@return 返回值</div><div class=\"line\">*/</div><div class=\"line\">void * zyq_invokeSelectorObjects(NSString *className,NSString* selectorName,...);</div></pre></td></tr></table></figure></p>\n<p>最后就是页面路由和方法路由遇到找不到的处理方案了，主要思路就是不crash、好判断，页面路由就判断一下是网页的就跳转url不是就报个提示算了，方法路由return nil吧。。这里仁者见仁智者见智，反正可以自己定制，差不多就讲到这吧。</p>"},{"title":"移动端Model层与Server服务层自动化","date":"2017-01-31T18:09:05.000Z","_content":"\n# Model层自动化\n### 前言（纯属捎带扯一下，后端大咖勿看）\n谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！\n无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。\n上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了\n### 后端的Model层\n后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql\n### 移动端的Model层\n先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。\n自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。\n### Model自动化实现\n上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考https://github.com/google/protobuf/blob/master/docs/third_party.md ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）\n#### Protobuf Convert转码\n下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）\n这里以Python为例，只是因为安装执行方便所以选它\n转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。\n<!-- more -->\n```python\n#头文件引用\nimport os\n\nfrom optparse import OptionParser\n#pb转成方便处理的对象\nfrom protoDef import *\n#读取pb的\nfrom protoReader import ProtoReader as reader\n#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法\n\nENUM_TYPE = 'NSInteger'\n#基础类型映射\ntypeMap = {\n'int64': 'NSNumber',\n'int32': 'NSNumber',\n'string': 'NSString',\n'bool': 'NSNumber',\n'float': 'NSNumber',\n'double': 'NSNumber',\n}\n#默认值映射\ndefaultMap = {\n'int64': '@(%s)',\n'int32': '@(%s)',\n'string': '@\"%s\"',\n'bool': '@(%s)',\n'float': '@(%s)',\n'double': '@(%s)',\n}\n\ndef _convertType(pClz):\nif typeMap.has_key(pClz):\nreturn typeMap[pClz]\nreturn pClz\n\ndef _convertDefault(pClz):\nif defaultMap.has_key(pClz):\nreturn defaultMap[pClz]\nreturn 'nil'\n#写文件方法（就是一点点输出oc的方法）\ndef _writeLine(outf, line = ''):\noutf.write(line + '\\n')\n\nclass IOSWriter:\ndef __init__(self, outDir, proto):\nself.outDir = outDir\nself.proto = proto\n\ndef __writeMsg(self, msg):\nif isDeprecated(msg.comment):\nreturn\n\nself.__writeMsgH(msg)#生成.h\nself.__writeMsgM(msg)#生成.m\n\n#为对应类添加前缀做为命名空间（oc没命名空间。。。）\ndef __makeMsgName(self, msg):\nif msg.protoPkg == '不想加前缀的条件':\nreturn msg.name\nreturn msg.protoPkg.upper() + msg.name\n\ndef __writeMsgH(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % msg.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\nimportSet = set()\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif self.proto.hasMsg(field.clz) and field.clz not in importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\nif self.__atClass(field):\n_writeLine(outf, '@class %s;' % importName)\nelse:\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf)\n# declare\n_writeLine(outf, '@interface %s : NSObject' % msgName)\n# field\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif field.repeated:\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray <%s*>* %s;' % (field.name, fieldType))\nelse\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray * %s;' % field.name)\nelif self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nif fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (fieldType, field.name))\nelif fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, '@property(nonatomic, assign) %s %s;' % (fieldType, field.name))\nelse:\nclz = _convertType(field.clz)\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (clz, field.name))\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\ndef __atClass(self, field):\nreturn '@class' in field.comment\n\ndef __writeMsgM(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % msgName)\nfor field in msg.fields:\nif self.proto.hasMsg(field.clz) and self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf, \"\\n@implementation %s\" % msgName)\n_writeLine(outf)\n# repeated\nkvlist = [] #数组内实体类 数组\ndvlist = [] #默认值 数组\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif typeMap.has_key(field.clz) and field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n#默认值设置\nif len(dvlist) > 0:\n_writeLine(outf, \"- (id)init {\")\n_writeLine(outf, \"   if(self=[super init]){ \")\nfor i, (name, default) in enumerate(dvlist):\nline = '''   _%s=%s''' % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, \"   } \")\n_writeLine(outf, \"   return self;\")\n_writeLine(outf, \"} \")\n\n#用了YYModel转换所以有了这个方法\nif len(kvlist) > 0:\n_writeLine(outf, \"+ (NSDictionary *)modelContainerPropertyGenericClass {\")\n_writeLine(outf, \"  return @{\")\nfor i, (name, clz) in enumerate(kvlist):\nline = '''    @\"%s\" : [%s class]''' % (name, clz)\nif i < len(kvlist) - 1:\nline = line + ','\n_writeLine(outf, line)\n_writeLine(outf, \"  };\")\n_writeLine(outf, \"}\")\n\n\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\n#生成枚举，之所以有.h .m是为了搞枚举string\ndef __writeEnum(self, enum):\nif isDeprecated(enum.comment):\nreturn\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\ndef __writeEnumH(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % enum.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\n_writeLine(outf)\n# declare\n_writeLine(outf, 'typedef enum {')\n# field\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0\nfor field in fields:\ni += 1\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif i == len(fields):\n_writeLine(outf, '  %s = %s' % (field.name, field.number))\nelse:\n_writeLine(outf, '  %s = %s,' % (field.name, field.number))\n_writeLine(outf, '} %s;' % enumName)\n_writeLine(outf)\n_writeLine(outf, '%s %sValueOf(NSString *text);' % (enumName, enumName))\n_writeLine(outf, 'NSString* %sDescription(%s value);' % (enumName, enumName))\n\noutf.close()\n\ndef __writeEnumM(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % enumName)\n_writeLine(outf)\n# valueOf\n_writeLine(outf, '%s %sValueOf(NSString *text) {' % (enumName, enumName))\n_writeLine(outf, '  if (text) {')\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0;\nfor field in fields:\nif i == 0:\n_writeLine(outf, '    if ([text isEqualToString:@\"%s\"])' % field.name)\nelse:\n_writeLine(outf, '    else if ([text isEqualToString:@\"%s\"])' % field.name)\n_writeLine(outf, '      return %s;' % field.name)\ni += 1\n_writeLine(outf, '  }')\n_writeLine(outf, '  return -1;')\n_writeLine(outf, '}\\n')\n# description\n_writeLine(outf, 'NSString* %sDescription(%s value) {' % (enumName, enumName))\n_writeLine(outf, '  switch (value) {')\nfor field in fields:\n_writeLine(outf, '    case %s:' % field.name)\n_writeLine(outf, '      return @\"%s\";' % field.name)\n_writeLine(outf, '  }')\n_writeLine(outf, '  return @\"\";')\n_writeLine(outf, '}')\n\noutf.close()\n\ndef write(self):\nfor msg in self.proto.definedMsgs:\nif msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\nelif msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n#写文件到本地\nif __name__ == '__main__':\nparser = OptionParser()\nparser.add_option(\"-r\", \"--root\", dest=\"protoDir\", help=\"root proto dir\", metavar=\"DIR\")\nparser.add_option(\"-f\", \"--file\", dest=\"protoFile\", help=\"input proto file\", metavar=\"FILE\")\nparser.add_option(\"-o\", \"--out\", dest=\"out\", help=\"output dir\", metavar=\"DIR\")\n\noptions, args = parser.parse_args()\n\nif not options.protoDir:\nparser.print_help()\nparser.error('no proto dir')\nif not options.protoFile:\nparser.print_help()\nparser.error('no proto file')\nif not options.out:\nparser.print_help()\nparser.error('no out dir')\n\nif not os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n\n```      \n上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了\n#### Server服务层自动化\n这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。\n源码地址：https://github.com/heroims/ServerAPI\n这里也只是简单说一下\nServerAPI 定义一个请求的地址，重试次数，返回数据转换模式\nServerAPIManager  根据ServerAPI发起请求\nServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）\nServerResult  返回的通用型实体包含解析的字典，错误信息等\n\n总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass\n\n回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。\n","source":"_posts/移动端Model层与Server服务层自动化.md","raw":"---\ntitle: 移动端Model层与Server服务层自动化\ndate: 2017-02-01 02:09:05\ntags:\n---\n\n# Model层自动化\n### 前言（纯属捎带扯一下，后端大咖勿看）\n谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！\n无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。\n上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了\n### 后端的Model层\n后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql\n### 移动端的Model层\n先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。\n自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。\n### Model自动化实现\n上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考https://github.com/google/protobuf/blob/master/docs/third_party.md ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）\n#### Protobuf Convert转码\n下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）\n这里以Python为例，只是因为安装执行方便所以选它\n转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。\n<!-- more -->\n```python\n#头文件引用\nimport os\n\nfrom optparse import OptionParser\n#pb转成方便处理的对象\nfrom protoDef import *\n#读取pb的\nfrom protoReader import ProtoReader as reader\n#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法\n\nENUM_TYPE = 'NSInteger'\n#基础类型映射\ntypeMap = {\n'int64': 'NSNumber',\n'int32': 'NSNumber',\n'string': 'NSString',\n'bool': 'NSNumber',\n'float': 'NSNumber',\n'double': 'NSNumber',\n}\n#默认值映射\ndefaultMap = {\n'int64': '@(%s)',\n'int32': '@(%s)',\n'string': '@\"%s\"',\n'bool': '@(%s)',\n'float': '@(%s)',\n'double': '@(%s)',\n}\n\ndef _convertType(pClz):\nif typeMap.has_key(pClz):\nreturn typeMap[pClz]\nreturn pClz\n\ndef _convertDefault(pClz):\nif defaultMap.has_key(pClz):\nreturn defaultMap[pClz]\nreturn 'nil'\n#写文件方法（就是一点点输出oc的方法）\ndef _writeLine(outf, line = ''):\noutf.write(line + '\\n')\n\nclass IOSWriter:\ndef __init__(self, outDir, proto):\nself.outDir = outDir\nself.proto = proto\n\ndef __writeMsg(self, msg):\nif isDeprecated(msg.comment):\nreturn\n\nself.__writeMsgH(msg)#生成.h\nself.__writeMsgM(msg)#生成.m\n\n#为对应类添加前缀做为命名空间（oc没命名空间。。。）\ndef __makeMsgName(self, msg):\nif msg.protoPkg == '不想加前缀的条件':\nreturn msg.name\nreturn msg.protoPkg.upper() + msg.name\n\ndef __writeMsgH(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % msg.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\nimportSet = set()\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif self.proto.hasMsg(field.clz) and field.clz not in importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\nif self.__atClass(field):\n_writeLine(outf, '@class %s;' % importName)\nelse:\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf)\n# declare\n_writeLine(outf, '@interface %s : NSObject' % msgName)\n# field\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif field.repeated:\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray <%s*>* %s;' % (field.name, fieldType))\nelse\n_writeLine(outf, '@property(nonatomic, strong) NSMutableArray * %s;' % field.name)\nelif self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nif fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (fieldType, field.name))\nelif fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, '@property(nonatomic, assign) %s %s;' % (fieldType, field.name))\nelse:\nclz = _convertType(field.clz)\n_writeLine(outf, '@property(nonatomic, strong) %s * %s;' % (clz, field.name))\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\ndef __atClass(self, field):\nreturn '@class' in field.comment\n\ndef __writeMsgM(self, msg):\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % msgName)\nfor field in msg.fields:\nif self.proto.hasMsg(field.clz) and self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, '#import \"%s.h\"' % importName)\n_writeLine(outf, \"\\n@implementation %s\" % msgName)\n_writeLine(outf)\n# repeated\nkvlist = [] #数组内实体类 数组\ndvlist = [] #默认值 数组\nfor field in msg.fields:\nif isDeprecated(field.comment):\ncontinue\nif typeMap.has_key(field.clz) and field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\nif field.repeated and not typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n#默认值设置\nif len(dvlist) > 0:\n_writeLine(outf, \"- (id)init {\")\n_writeLine(outf, \"   if(self=[super init]){ \")\nfor i, (name, default) in enumerate(dvlist):\nline = '''   _%s=%s''' % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, \"   } \")\n_writeLine(outf, \"   return self;\")\n_writeLine(outf, \"} \")\n\n#用了YYModel转换所以有了这个方法\nif len(kvlist) > 0:\n_writeLine(outf, \"+ (NSDictionary *)modelContainerPropertyGenericClass {\")\n_writeLine(outf, \"  return @{\")\nfor i, (name, clz) in enumerate(kvlist):\nline = '''    @\"%s\" : [%s class]''' % (name, clz)\nif i < len(kvlist) - 1:\nline = line + ','\n_writeLine(outf, line)\n_writeLine(outf, \"  };\")\n_writeLine(outf, \"}\")\n\n\n# end\n_writeLine(outf, '\\n@end')\noutf.close()\n\n#生成枚举，之所以有.h .m是为了搞枚举string\ndef __writeEnum(self, enum):\nif isDeprecated(enum.comment):\nreturn\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\ndef __writeEnumH(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .h\noutf = file(path + '.h', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# comment\n_writeLine(outf, '/**\\n * %s\\n */' % enum.comment)\n# import\n_writeLine(outf, '#import <Foundation/Foundation.h>')\n_writeLine(outf)\n# declare\n_writeLine(outf, 'typedef enum {')\n# field\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0\nfor field in fields:\ni += 1\nif field.comment:\n_writeLine(outf, '/**\\n * %s\\n */' % field.comment)\nif i == len(fields):\n_writeLine(outf, '  %s = %s' % (field.name, field.number))\nelse:\n_writeLine(outf, '  %s = %s,' % (field.name, field.number))\n_writeLine(outf, '} %s;' % enumName)\n_writeLine(outf)\n_writeLine(outf, '%s %sValueOf(NSString *text);' % (enumName, enumName))\n_writeLine(outf, 'NSString* %sDescription(%s value);' % (enumName, enumName))\n\noutf.close()\n\ndef __writeEnumM(self, enum):\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n# .m\noutf = file(path + '.m', 'w')\n_writeLine(outf, '/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n' % self.proto.filePath)\n# import\n_writeLine(outf, '#import \"%s.h\"' % enumName)\n_writeLine(outf)\n# valueOf\n_writeLine(outf, '%s %sValueOf(NSString *text) {' % (enumName, enumName))\n_writeLine(outf, '  if (text) {')\nfields = []\nfor field in enum.fields:\nif isDeprecated(field.comment):\ncontinue\nfields.append(field)\ni = 0;\nfor field in fields:\nif i == 0:\n_writeLine(outf, '    if ([text isEqualToString:@\"%s\"])' % field.name)\nelse:\n_writeLine(outf, '    else if ([text isEqualToString:@\"%s\"])' % field.name)\n_writeLine(outf, '      return %s;' % field.name)\ni += 1\n_writeLine(outf, '  }')\n_writeLine(outf, '  return -1;')\n_writeLine(outf, '}\\n')\n# description\n_writeLine(outf, 'NSString* %sDescription(%s value) {' % (enumName, enumName))\n_writeLine(outf, '  switch (value) {')\nfor field in fields:\n_writeLine(outf, '    case %s:' % field.name)\n_writeLine(outf, '      return @\"%s\";' % field.name)\n_writeLine(outf, '  }')\n_writeLine(outf, '  return @\"\";')\n_writeLine(outf, '}')\n\noutf.close()\n\ndef write(self):\nfor msg in self.proto.definedMsgs:\nif msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\nelif msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n#写文件到本地\nif __name__ == '__main__':\nparser = OptionParser()\nparser.add_option(\"-r\", \"--root\", dest=\"protoDir\", help=\"root proto dir\", metavar=\"DIR\")\nparser.add_option(\"-f\", \"--file\", dest=\"protoFile\", help=\"input proto file\", metavar=\"FILE\")\nparser.add_option(\"-o\", \"--out\", dest=\"out\", help=\"output dir\", metavar=\"DIR\")\n\noptions, args = parser.parse_args()\n\nif not options.protoDir:\nparser.print_help()\nparser.error('no proto dir')\nif not options.protoFile:\nparser.print_help()\nparser.error('no proto file')\nif not options.out:\nparser.print_help()\nparser.error('no out dir')\n\nif not os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n\n```      \n上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了\n#### Server服务层自动化\n这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。\n源码地址：https://github.com/heroims/ServerAPI\n这里也只是简单说一下\nServerAPI 定义一个请求的地址，重试次数，返回数据转换模式\nServerAPIManager  根据ServerAPI发起请求\nServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）\nServerResult  返回的通用型实体包含解析的字典，错误信息等\n\n总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass\n\n回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。\n","slug":"移动端Model层与Server服务层自动化","published":1,"updated":"2017-08-13T20:28:06.000Z","_id":"cj6b62e160005u16al1di9yb1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Model层自动化\"><a href=\"#Model层自动化\" class=\"headerlink\" title=\"Model层自动化\"></a>Model层自动化</h1><h3 id=\"前言（纯属捎带扯一下，后端大咖勿看）\"><a href=\"#前言（纯属捎带扯一下，后端大咖勿看）\" class=\"headerlink\" title=\"前言（纯属捎带扯一下，后端大咖勿看）\"></a>前言（纯属捎带扯一下，后端大咖勿看）</h3><p>谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！<br>无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。<br>上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了</p>\n<h3 id=\"后端的Model层\"><a href=\"#后端的Model层\" class=\"headerlink\" title=\"后端的Model层\"></a>后端的Model层</h3><p>后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql</p>\n<h3 id=\"移动端的Model层\"><a href=\"#移动端的Model层\" class=\"headerlink\" title=\"移动端的Model层\"></a>移动端的Model层</h3><p>先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。<br>自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。</p>\n<h3 id=\"Model自动化实现\"><a href=\"#Model自动化实现\" class=\"headerlink\" title=\"Model自动化实现\"></a>Model自动化实现</h3><p>上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考<a href=\"https://github.com/google/protobuf/blob/master/docs/third_party.md\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/blob/master/docs/third_party.md</a> ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）</p>\n<h4 id=\"Protobuf-Convert转码\"><a href=\"#Protobuf-Convert转码\" class=\"headerlink\" title=\"Protobuf Convert转码\"></a>Protobuf Convert转码</h4><p>下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）<br>这里以Python为例，只是因为安装执行方便所以选它<br>转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。<br><a id=\"more\"></a></p>\n<pre><code class=\"python\"><span class=\"comment\">#头文件引用</span>\n<span class=\"keyword\">import</span> os\n\n<span class=\"keyword\">from</span> optparse <span class=\"keyword\">import</span> OptionParser\n<span class=\"comment\">#pb转成方便处理的对象</span>\n<span class=\"keyword\">from</span> protoDef <span class=\"keyword\">import</span> *\n<span class=\"comment\">#读取pb的</span>\n<span class=\"keyword\">from</span> protoReader <span class=\"keyword\">import</span> ProtoReader <span class=\"keyword\">as</span> reader\n<span class=\"comment\">#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法</span>\n\nENUM_TYPE = <span class=\"string\">'NSInteger'</span>\n<span class=\"comment\">#基础类型映射</span>\ntypeMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'NSString'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'NSNumber'</span>,\n}\n<span class=\"comment\">#默认值映射</span>\ndefaultMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'@\"%s\"'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'@(%s)'</span>,\n}\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertType</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> typeMap.has_key(pClz):\n<span class=\"keyword\">return</span> typeMap[pClz]\n<span class=\"keyword\">return</span> pClz\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertDefault</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> defaultMap.has_key(pClz):\n<span class=\"keyword\">return</span> defaultMap[pClz]\n<span class=\"keyword\">return</span> <span class=\"string\">'nil'</span>\n<span class=\"comment\">#写文件方法（就是一点点输出oc的方法）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_writeLine</span><span class=\"params\">(outf, line = <span class=\"string\">''</span>)</span>:</span>\noutf.write(line + <span class=\"string\">'\\n'</span>)\n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOSWriter</span>:</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, outDir, proto)</span>:</span>\nself.outDir = outDir\nself.proto = proto\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsg</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(msg.comment):\n<span class=\"keyword\">return</span>\n\nself.__writeMsgH(msg)<span class=\"comment\">#生成.h</span>\nself.__writeMsgM(msg)<span class=\"comment\">#生成.m</span>\n\n<span class=\"comment\">#为对应类添加前缀做为命名空间（oc没命名空间。。。）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__makeMsgName</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> msg.protoPkg == <span class=\"string\">'不想加前缀的条件'</span>:\n<span class=\"keyword\">return</span> msg.name\n<span class=\"keyword\">return</span> msg.protoPkg.upper() + msg.name\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgH</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % msg.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\nimportSet = set()\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> field.clz <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n<span class=\"keyword\">if</span> self.__atClass(field):\n_writeLine(outf, <span class=\"string\">'@class %s;'</span> % importName)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'@interface %s : NSObject'</span> % msgName)\n<span class=\"comment\"># field</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> field.repeated:\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray &lt;%s*&gt;* %s;'</span> % (field.name, fieldType))\n<span class=\"keyword\">else</span>\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray * %s;'</span> % field.name)\n<span class=\"keyword\">elif</span> self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n<span class=\"keyword\">if</span> fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">elif</span> fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, assign) %s %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">else</span>:\nclz = _convertType(field.clz)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (clz, field.name))\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__atClass</span><span class=\"params\">(self, field)</span>:</span>\n<span class=\"keyword\">return</span> <span class=\"string\">'@class'</span> <span class=\"keyword\">in</span> field.comment\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgM</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % msgName)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf, <span class=\"string\">\"\\n@implementation %s\"</span> % msgName)\n_writeLine(outf)\n<span class=\"comment\"># repeated</span>\nkvlist = [] <span class=\"comment\">#数组内实体类 数组</span>\ndvlist = [] <span class=\"comment\">#默认值 数组</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> typeMap.has_key(field.clz) <span class=\"keyword\">and</span> field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n<span class=\"comment\">#默认值设置</span>\n<span class=\"keyword\">if</span> len(dvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"- (id)init {\"</span>)\n_writeLine(outf, <span class=\"string\">\"   if(self=[super init]){ \"</span>)\n<span class=\"keyword\">for</span> i, (name, default) <span class=\"keyword\">in</span> enumerate(dvlist):\nline = <span class=\"string\">'''   _%s=%s'''</span> % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"   } \"</span>)\n_writeLine(outf, <span class=\"string\">\"   return self;\"</span>)\n_writeLine(outf, <span class=\"string\">\"} \"</span>)\n\n<span class=\"comment\">#用了YYModel转换所以有了这个方法</span>\n<span class=\"keyword\">if</span> len(kvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"+ (NSDictionary *)modelContainerPropertyGenericClass {\"</span>)\n_writeLine(outf, <span class=\"string\">\"  return @{\"</span>)\n<span class=\"keyword\">for</span> i, (name, clz) <span class=\"keyword\">in</span> enumerate(kvlist):\nline = <span class=\"string\">'''    @\"%s\" : [%s class]'''</span> % (name, clz)\n<span class=\"keyword\">if</span> i &lt; len(kvlist) - <span class=\"number\">1</span>:\nline = line + <span class=\"string\">','</span>\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"  };\"</span>)\n_writeLine(outf, <span class=\"string\">\"}\"</span>)\n\n\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"comment\">#生成枚举，之所以有.h .m是为了搞枚举string</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnum</span><span class=\"params\">(self, enum)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(enum.comment):\n<span class=\"keyword\">return</span>\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumH</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % enum.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'typedef enum {'</span>)\n<span class=\"comment\"># field</span>\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\ni += <span class=\"number\">1</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> i == len(fields):\n_writeLine(outf, <span class=\"string\">'  %s = %s'</span> % (field.name, field.number))\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'  %s = %s,'</span> % (field.name, field.number))\n_writeLine(outf, <span class=\"string\">'} %s;'</span> % enumName)\n_writeLine(outf)\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text);'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value);'</span> % (enumName, enumName))\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumM</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % enumName)\n_writeLine(outf)\n<span class=\"comment\"># valueOf</span>\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  if (text) {'</span>)\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>;\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n<span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">'    if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'    else if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return %s;'</span> % field.name)\ni += <span class=\"number\">1</span>\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return -1;'</span>)\n_writeLine(outf, <span class=\"string\">'}\\n'</span>)\n<span class=\"comment\"># description</span>\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  switch (value) {'</span>)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n_writeLine(outf, <span class=\"string\">'    case %s:'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return @\"%s\";'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return @\"\";'</span>)\n_writeLine(outf, <span class=\"string\">'}'</span>)\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(self)</span>:</span>\n<span class=\"keyword\">for</span> msg <span class=\"keyword\">in</span> self.proto.definedMsgs:\n<span class=\"keyword\">if</span> msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\n<span class=\"keyword\">elif</span> msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n<span class=\"comment\">#写文件到本地</span>\n<span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:\nparser = OptionParser()\nparser.add_option(<span class=\"string\">\"-r\"</span>, <span class=\"string\">\"--root\"</span>, dest=<span class=\"string\">\"protoDir\"</span>, help=<span class=\"string\">\"root proto dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\nparser.add_option(<span class=\"string\">\"-f\"</span>, <span class=\"string\">\"--file\"</span>, dest=<span class=\"string\">\"protoFile\"</span>, help=<span class=\"string\">\"input proto file\"</span>, metavar=<span class=\"string\">\"FILE\"</span>)\nparser.add_option(<span class=\"string\">\"-o\"</span>, <span class=\"string\">\"--out\"</span>, dest=<span class=\"string\">\"out\"</span>, help=<span class=\"string\">\"output dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\n\noptions, args = parser.parse_args()\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoDir:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto dir'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoFile:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto file'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.out:\nparser.print_help()\nparser.error(<span class=\"string\">'no out dir'</span>)\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n</code></pre>\n<p>上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了</p>\n<h4 id=\"Server服务层自动化\"><a href=\"#Server服务层自动化\" class=\"headerlink\" title=\"Server服务层自动化\"></a>Server服务层自动化</h4><p>这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。<br>源码地址：<a href=\"https://github.com/heroims/ServerAPI\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPI</a><br>这里也只是简单说一下<br>ServerAPI 定义一个请求的地址，重试次数，返回数据转换模式<br>ServerAPIManager  根据ServerAPI发起请求<br>ServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）<br>ServerResult  返回的通用型实体包含解析的字典，错误信息等</p>\n<p>总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass</p>\n<p>回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Model层自动化\"><a href=\"#Model层自动化\" class=\"headerlink\" title=\"Model层自动化\"></a>Model层自动化</h1><h3 id=\"前言（纯属捎带扯一下，后端大咖勿看）\"><a href=\"#前言（纯属捎带扯一下，后端大咖勿看）\" class=\"headerlink\" title=\"前言（纯属捎带扯一下，后端大咖勿看）\"></a>前言（纯属捎带扯一下，后端大咖勿看）</h3><p>谈到Model层自动化的产出我们就来从最初的地方开始讲，数据库！<br>无论你是用啥写服务器如果还手写Model那真的只能说你够low我服！不过如果是手写Model自动生成数据库那另说，总的来说就是要么从数据库转实体出来，要么从实体转数据库这才有点意思。<br>上边只是开玩笑下面正题，很多时候大家都无奈没办法不能说low不low，其中奥妙各有体会，通常有点规模的团队都是先定义表然后就出Model了</p>\n<h3 id=\"后端的Model层\"><a href=\"#后端的Model层\" class=\"headerlink\" title=\"后端的Model层\"></a>后端的Model层</h3><p>后端数据库和实体互转的方案都不用Google，百度就能出来一大推，有直接读库生成的，也有从实体转sql生成库的，更有提前定义协议然后开始出对应模块对应语言的实体及sql</p>\n<h3 id=\"移动端的Model层\"><a href=\"#移动端的Model层\" class=\"headerlink\" title=\"移动端的Model层\"></a>移动端的Model层</h3><p>先继续谈会后台Model，这里要说的只是最好有一个提前定义的过程，这样一方面规范开发流程提前想好怎样建库合理，一方面有利于跨平台跨语言的开发，有了提前定义的协议，Model和枚举的各平台自动生成就方便了很多，写个简单的小程序即可，类型也就那几类。关键真的是一劳永逸，省去了大家互相校对的过程。<br>自动化生成移动端乃至前端用的Model层说白了就是做个类型映射，细说的话基本就是分为两类，一类直接就着后端现有项目读Model层的文件，然后做个类型的映射直接导出移动端需要的类，另一类也就是设计数据库时先定义Model的协议，然后根据协议自动生成各个平台需要的实体，而协议定义通常用序列化后的数据如xml(极力抵制，结构复杂)，json，pb，sql文件都能干这事。</p>\n<h3 id=\"Model自动化实现\"><a href=\"#Model自动化实现\" class=\"headerlink\" title=\"Model自动化实现\"></a>Model自动化实现</h3><p>上面说到了xml，json，pb，sql文件都能干这件事，但其中最容易就是json，github上搜个json class基本就能有一大片总有你想要的语言，但json的局限在于也就能转换一下model，当然通过特殊定义中间转换，枚举啥的也能搞定，在这我推荐pb，首先它就是专门用来定义协议的，枚举实体不用说都能搞定，包括默认值设置也能写出来，而且是谷歌出品本身是im通讯协议，被它序列化的数据在上面说的里面算是最小的，而另一方面关于转码参考<a href=\"https://github.com/google/protobuf/blob/master/docs/third_party.md\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/blob/master/docs/third_party.md</a> ，直接开放了各个语言的转换方法，当然你根本用不到它里面写的那么复杂，它的里面实体可是直接带pb转换model方法的，如果不是开发im根本用不到，要删部分源码实现自己的需要也行，。。。（下面讲一下正经方法）</p>\n<h4 id=\"Protobuf-Convert转码\"><a href=\"#Protobuf-Convert转码\" class=\"headerlink\" title=\"Protobuf Convert转码\"></a>Protobuf Convert转码</h4><p>下面放代码片段（反馈的人多放全的，之所以不想放还有个原因是这边实现有点粗）<br>这里以Python为例，只是因为安装执行方便所以选它<br>转成OC的例子，之所以选OC因为我就是个搞IOS的。。。写起来各个公司需求不同每次都要改改改。。。也就是这个原因懒得放全的了，因为用的人说到底还是需要手动改成自己想要的，没有通用的。。。<br>","more":"</p>\n<pre><code class=\"python\"><span class=\"comment\">#头文件引用</span>\n<span class=\"keyword\">import</span> os\n\n<span class=\"keyword\">from</span> optparse <span class=\"keyword\">import</span> OptionParser\n<span class=\"comment\">#pb转成方便处理的对象</span>\n<span class=\"keyword\">from</span> protoDef <span class=\"keyword\">import</span> *\n<span class=\"comment\">#读取pb的</span>\n<span class=\"keyword\">from</span> protoReader <span class=\"keyword\">import</span> ProtoReader <span class=\"keyword\">as</span> reader\n<span class=\"comment\">#上边两个就不放源码了，感兴趣的人多再说，毕竟上边的实现只是读pb逻辑大家估计都有自己的好办法</span>\n\nENUM_TYPE = <span class=\"string\">'NSInteger'</span>\n<span class=\"comment\">#基础类型映射</span>\ntypeMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'NSString'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'NSNumber'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'NSNumber'</span>,\n}\n<span class=\"comment\">#默认值映射</span>\ndefaultMap = {\n<span class=\"string\">'int64'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'int32'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'string'</span>: <span class=\"string\">'@\"%s\"'</span>,\n<span class=\"string\">'bool'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'float'</span>: <span class=\"string\">'@(%s)'</span>,\n<span class=\"string\">'double'</span>: <span class=\"string\">'@(%s)'</span>,\n}\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertType</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> typeMap.has_key(pClz):\n<span class=\"keyword\">return</span> typeMap[pClz]\n<span class=\"keyword\">return</span> pClz\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_convertDefault</span><span class=\"params\">(pClz)</span>:</span>\n<span class=\"keyword\">if</span> defaultMap.has_key(pClz):\n<span class=\"keyword\">return</span> defaultMap[pClz]\n<span class=\"keyword\">return</span> <span class=\"string\">'nil'</span>\n<span class=\"comment\">#写文件方法（就是一点点输出oc的方法）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_writeLine</span><span class=\"params\">(outf, line = <span class=\"string\">''</span>)</span>:</span>\noutf.write(line + <span class=\"string\">'\\n'</span>)\n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOSWriter</span>:</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, outDir, proto)</span>:</span>\nself.outDir = outDir\nself.proto = proto\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsg</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(msg.comment):\n<span class=\"keyword\">return</span>\n\nself.__writeMsgH(msg)<span class=\"comment\">#生成.h</span>\nself.__writeMsgM(msg)<span class=\"comment\">#生成.m</span>\n\n<span class=\"comment\">#为对应类添加前缀做为命名空间（oc没命名空间。。。）</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__makeMsgName</span><span class=\"params\">(self, msg)</span>:</span>\n<span class=\"keyword\">if</span> msg.protoPkg == <span class=\"string\">'不想加前缀的条件'</span>:\n<span class=\"keyword\">return</span> msg.name\n<span class=\"keyword\">return</span> msg.protoPkg.upper() + msg.name\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgH</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msg.name)\n\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % msg.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\nimportSet = set()\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> field.clz <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> importSet:\nimportSet.add(field.clz)\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n<span class=\"keyword\">if</span> self.__atClass(field):\n_writeLine(outf, <span class=\"string\">'@class %s;'</span> % importName)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'@interface %s : NSObject'</span> % msgName)\n<span class=\"comment\"># field</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> field.repeated:\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray &lt;%s*&gt;* %s;'</span> % (field.name, fieldType))\n<span class=\"keyword\">else</span>\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) NSMutableArray * %s;'</span> % field.name)\n<span class=\"keyword\">elif</span> self.proto.hasMsg(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\n<span class=\"keyword\">if</span> fieldMsg.kind == Proto.PROTO_MSG:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">elif</span> fieldMsg.kind == Proto.PROTO_ENUM:\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, assign) %s %s;'</span> % (fieldType, field.name))\n<span class=\"keyword\">else</span>:\nclz = _convertType(field.clz)\n_writeLine(outf, <span class=\"string\">'@property(nonatomic, strong) %s * %s;'</span> % (clz, field.name))\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__atClass</span><span class=\"params\">(self, field)</span>:</span>\n<span class=\"keyword\">return</span> <span class=\"string\">'@class'</span> <span class=\"keyword\">in</span> field.comment\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeMsgM</span><span class=\"params\">(self, msg)</span>:</span>\nmsgName = self.__makeMsgName(msg)\npath = os.path.join(self.outDir, msgName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % msgName)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> self.proto.hasMsg(field.clz) <span class=\"keyword\">and</span> self.__atClass(field):\nimportMsg = self.proto.getMsg(field.clz)\nimportName = self.__makeMsgName(importMsg)\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % importName)\n_writeLine(outf, <span class=\"string\">\"\\n@implementation %s\"</span> % msgName)\n_writeLine(outf)\n<span class=\"comment\"># repeated</span>\nkvlist = [] <span class=\"comment\">#数组内实体类 数组</span>\ndvlist = [] <span class=\"comment\">#默认值 数组</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> msg.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\n<span class=\"keyword\">if</span> typeMap.has_key(field.clz) <span class=\"keyword\">and</span> field.default:\ndefault=_convertDefault(field.default)\ndvlist.append((field.name,default))\n<span class=\"keyword\">if</span> field.repeated <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> typeMap.has_key(field.clz):\nfieldMsg = self.proto.getMsg(field.clz)\nfieldType = self.__makeMsgName(fieldMsg)\nkvlist.append((field.name, fieldType))\n<span class=\"comment\">#默认值设置</span>\n<span class=\"keyword\">if</span> len(dvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"- (id)init {\"</span>)\n_writeLine(outf, <span class=\"string\">\"   if(self=[super init]){ \"</span>)\n<span class=\"keyword\">for</span> i, (name, default) <span class=\"keyword\">in</span> enumerate(dvlist):\nline = <span class=\"string\">'''   _%s=%s'''</span> % (name, default)\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"   } \"</span>)\n_writeLine(outf, <span class=\"string\">\"   return self;\"</span>)\n_writeLine(outf, <span class=\"string\">\"} \"</span>)\n\n<span class=\"comment\">#用了YYModel转换所以有了这个方法</span>\n<span class=\"keyword\">if</span> len(kvlist) &gt; <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">\"+ (NSDictionary *)modelContainerPropertyGenericClass {\"</span>)\n_writeLine(outf, <span class=\"string\">\"  return @{\"</span>)\n<span class=\"keyword\">for</span> i, (name, clz) <span class=\"keyword\">in</span> enumerate(kvlist):\nline = <span class=\"string\">'''    @\"%s\" : [%s class]'''</span> % (name, clz)\n<span class=\"keyword\">if</span> i &lt; len(kvlist) - <span class=\"number\">1</span>:\nline = line + <span class=\"string\">','</span>\n_writeLine(outf, line)\n_writeLine(outf, <span class=\"string\">\"  };\"</span>)\n_writeLine(outf, <span class=\"string\">\"}\"</span>)\n\n\n<span class=\"comment\"># end</span>\n_writeLine(outf, <span class=\"string\">'\\n@end'</span>)\noutf.close()\n\n<span class=\"comment\">#生成枚举，之所以有.h .m是为了搞枚举string</span>\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnum</span><span class=\"params\">(self, enum)</span>:</span>\n<span class=\"keyword\">if</span> isDeprecated(enum.comment):\n<span class=\"keyword\">return</span>\nself.__writeEnumH(enum)\nself.__writeEnumM(enum)\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumH</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .h</span>\noutf = file(path + <span class=\"string\">'.h'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># comment</span>\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % enum.comment)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import &lt;Foundation/Foundation.h&gt;'</span>)\n_writeLine(outf)\n<span class=\"comment\"># declare</span>\n_writeLine(outf, <span class=\"string\">'typedef enum {'</span>)\n<span class=\"comment\"># field</span>\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\ni += <span class=\"number\">1</span>\n<span class=\"keyword\">if</span> field.comment:\n_writeLine(outf, <span class=\"string\">'/**\\n * %s\\n */'</span> % field.comment)\n<span class=\"keyword\">if</span> i == len(fields):\n_writeLine(outf, <span class=\"string\">'  %s = %s'</span> % (field.name, field.number))\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'  %s = %s,'</span> % (field.name, field.number))\n_writeLine(outf, <span class=\"string\">'} %s;'</span> % enumName)\n_writeLine(outf)\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text);'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value);'</span> % (enumName, enumName))\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__writeEnumM</span><span class=\"params\">(self, enum)</span>:</span>\nenumName = self.__makeMsgName(enum)\npath = os.path.join(self.outDir, enumName)\n<span class=\"comment\"># .m</span>\noutf = file(path + <span class=\"string\">'.m'</span>, <span class=\"string\">'w'</span>)\n_writeLine(outf, <span class=\"string\">'/*\\n * generated by proto-pygen, NEVER CHANGE!!\\n * source file: %s\\n */\\n'</span> % self.proto.filePath)\n<span class=\"comment\"># import</span>\n_writeLine(outf, <span class=\"string\">'#import \"%s.h\"'</span> % enumName)\n_writeLine(outf)\n<span class=\"comment\"># valueOf</span>\n_writeLine(outf, <span class=\"string\">'%s %sValueOf(NSString *text) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  if (text) {'</span>)\nfields = []\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> enum.fields:\n<span class=\"keyword\">if</span> isDeprecated(field.comment):\n<span class=\"keyword\">continue</span>\nfields.append(field)\ni = <span class=\"number\">0</span>;\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n<span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:\n_writeLine(outf, <span class=\"string\">'    if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n<span class=\"keyword\">else</span>:\n_writeLine(outf, <span class=\"string\">'    else if ([text isEqualToString:@\"%s\"])'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return %s;'</span> % field.name)\ni += <span class=\"number\">1</span>\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return -1;'</span>)\n_writeLine(outf, <span class=\"string\">'}\\n'</span>)\n<span class=\"comment\"># description</span>\n_writeLine(outf, <span class=\"string\">'NSString* %sDescription(%s value) {'</span> % (enumName, enumName))\n_writeLine(outf, <span class=\"string\">'  switch (value) {'</span>)\n<span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> fields:\n_writeLine(outf, <span class=\"string\">'    case %s:'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'      return @\"%s\";'</span> % field.name)\n_writeLine(outf, <span class=\"string\">'  }'</span>)\n_writeLine(outf, <span class=\"string\">'  return @\"\";'</span>)\n_writeLine(outf, <span class=\"string\">'}'</span>)\n\noutf.close()\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(self)</span>:</span>\n<span class=\"keyword\">for</span> msg <span class=\"keyword\">in</span> self.proto.definedMsgs:\n<span class=\"keyword\">if</span> msg.kind == Proto.PROTO_MSG:\nself.__writeMsg(msg)\n<span class=\"keyword\">elif</span> msg.kind == Proto.PROTO_ENUM:\nself.__writeEnum(msg)\n\n<span class=\"comment\">#写文件到本地</span>\n<span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:\nparser = OptionParser()\nparser.add_option(<span class=\"string\">\"-r\"</span>, <span class=\"string\">\"--root\"</span>, dest=<span class=\"string\">\"protoDir\"</span>, help=<span class=\"string\">\"root proto dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\nparser.add_option(<span class=\"string\">\"-f\"</span>, <span class=\"string\">\"--file\"</span>, dest=<span class=\"string\">\"protoFile\"</span>, help=<span class=\"string\">\"input proto file\"</span>, metavar=<span class=\"string\">\"FILE\"</span>)\nparser.add_option(<span class=\"string\">\"-o\"</span>, <span class=\"string\">\"--out\"</span>, dest=<span class=\"string\">\"out\"</span>, help=<span class=\"string\">\"output dir\"</span>, metavar=<span class=\"string\">\"DIR\"</span>)\n\noptions, args = parser.parse_args()\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoDir:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto dir'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.protoFile:\nparser.print_help()\nparser.error(<span class=\"string\">'no proto file'</span>)\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> options.out:\nparser.print_help()\nparser.error(<span class=\"string\">'no out dir'</span>)\n\n<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(options.out):\nos.makedirs(options.out)\n\nproto = reader(options.protoDir, options.protoFile).read()\nIOSWriter(options.out, proto).write()\n</code></pre>\n<p>上边就是Protobuf 转Model的逻辑，有了这个前提，下边Server服务层的自动化就有了</p>\n<h4 id=\"Server服务层自动化\"><a href=\"#Server服务层自动化\" class=\"headerlink\" title=\"Server服务层自动化\"></a>Server服务层自动化</h4><p>这里可以引申一下基本上写功能时只要分成配置类和启动器这样，根据配置类就可以实现自动化了，这里就拿IOS我这的实现讲。<br>源码地址：<a href=\"https://github.com/heroims/ServerAPI\" target=\"_blank\" rel=\"external\">https://github.com/heroims/ServerAPI</a><br>这里也只是简单说一下<br>ServerAPI 定义一个请求的地址，重试次数，返回数据转换模式<br>ServerAPIManager  根据ServerAPI发起请求<br>ServerAPIProtocol  定义需要实现的方法（为了扩展性高，这里定义必须实现的协议，具体需要定制的需求通过Category实现相关方法）<br>ServerResult  返回的通用型实体包含解析的字典，错误信息等</p>\n<p>总的思路就是ServerAPI来定义一个请求的具体内容参数，而ServerAPIManager负责发起请求返回数据，然后就只需要继承ServerAPI对不同请求具体参数直接返回具体的值即可，比如requestHost，resultFormat，retryTimes，timeOut，returnClass</p>\n<p>回到Protobuf这个就相当于定义request，但差别还是很大有了对一个API的描述，那么移动端包括后端，前端都可以通过这个描述来做对应的事情，只需要封装一个东西去处理描述，至此就完成了Server服务层的自动化，外加说一句后端的话为了性能可能更好的方案是根据描述生成代码吧，用代码写代码才是正道。。。。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}